<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star Conquest Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden
        }

        #gameContainer {
            width: 100vw;
            height: 100vh
        }

        .ui {
            position: absolute;
            top: 0;
            left: 0;
            color: white;
            z-index: 1000
        }

        .round {
            font-size: 24px;
            font-weight: bold;
            margin: 8px
        }

        .planning {
            font-size: 24px;
            color: #ff0;
            margin: 10px
        }

        .timer-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            z-index: 1001
        }

        .timer {
            height: 5px;
            background: white;
            width: 100vw;
            display: none;
            will-change: width;
        }

        .scores {
            position: fixed;
            top: 5px;
            right: 20px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            cursor: pointer;
            user-select: none
        }

        .score-row {
            margin-bottom: 1px;
            height: 30px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .score-row:hover:not(.multiplier-row):not(.selected-team) {
            transform: translateX(-2px);
            box-shadow: 2px 0px 4px rgba(0, 0, 0, 0.3);
        }

        .score-row:hover:not(.multiplier-row).selected-team {
            box-shadow: 2px 0px 4px rgba(0, 0, 0, 0.3);
        }

        .score-row.multiplier-row {
            cursor: default;
        }

        .main-score-section {
            position: relative;
            display: flex;
            align-items: center
        }

        .score-highlight {
            position: absolute;
            left: 0;
            height: 30px;
            z-index: 1;
        }

        .scores.expanded .score-highlight {
            right: 0;
            width: 100% !important;
        }

        .score-content {
            position: relative;
            z-index: 2;
            color: white;
            font-weight: bold;
            font-size: 16px;
            padding: 0 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            height: 30px;
            text-shadow: -1px -0.5px 3px rgba(0, 0, 0, 1)
        }

        .score-number {
            color: white
        }

        .detail-col {
            text-align: right;
            display: inline-block;
            font-size: 14px;
            font-weight: bold
        }

        .detail-section {
            display: none
        }

        .scores.expanded .detail-section {
            display: flex;
            gap: 8px
        }

        .steal-circle {
            width: 15px;
            height: 15px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: normal;
            color: black;
            box-shadow: -1px -1px 1px rgba(0, 0, 0, 0.5);
            text-shadow: none
        }

        .multipliers {
            display: none;
            font-size: 11px;
            color: #ccc;
            margin-top: 5px;
            justify-content: flex-end
        }

        .scores.expanded .multipliers {
            display: flex;
            gap: 8px
        }

        .multiplier-col {
            text-align: center;
            display: inline-block;
            font-size: 11px;
            font-weight: normal
        }

        .settings-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            color: white;
            min-width: 300px;
            z-index: 1002
        }

        .settings-panel h3 {
            margin-top: 0;
            color: #ff0
        }

        .setting-group {
            margin-bottom: 15px
        }

        .setting-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px
        }

        .setting-group input,
        .setting-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #555;
            background: #222;
            color: white;
            border-radius: 4px;
            box-sizing: border-box
        }

        .setting-group textarea {
            height: 100px;
            resize: vertical;
            font-family: monospace;
            font-size: 12px
        }

        .multiplier-settings {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .multiplier-input {
            width: 23%;
            padding: 4px;
            border: 1px solid #555;
            background: #222;
            color: white;
            border-radius: 4px;
            box-sizing: border-box;
            text-align: center;
            font-size: 12px;
        }

        .button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px
        }

        .button:hover {
            background: #0080ff
        }

        .button.start {
            background: #00cc00
        }

        .button.start:hover {
            background: #00ff00
        }

        .button.toggle {
            background: #666
        }

        .button.toggle:hover {
            background: #888
        }

        .error {
            color: #ff6666;
            font-size: 12px;
            margin-top: 5px
        }

        .ai-bot-item {
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ai-bot-select,
        .ai-team-select,
        .ai-aggression-select {
            padding: 4px;
            border: 1px solid #555;
            background: #222;
            color: white;
            border-radius: 4px;
            font-size: 12px;
        }

        .ai-bot-cube {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            display: inline-block;
            margin-right: 5px;
            position: relative;
        }

        .ai-bot-cube::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 1px;
        }

        .remove-bot-btn {
            background: #cc0000;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .remove-bot-btn:hover {
            background: #ff0000;
        }

        .hidden {
            display: none
        }

        .header {
            position: fixed;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1003;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            line-height: 1
        }

        .header .info-line {
            margin-top: 1px
        }

        #teamColor {
            color: cyan;
            font-weight: bold
        }

        .timer-container+.ui {
            margin-top: 5px
        }
    </style>
</head>

<body>
    <div id="gameContainer"></div>
    <div class="timer-container">
        <div id="timer" class="timer"></div>
    </div>
    <div class="header" id="gameHeader" style="display:none;">
        <div id="titleLine"></div>
        <div class="info-line">Game ID: Placeholder.â € My team: <span id="teamColor">cyan</span>.â € Breakout room #1</div>
    </div>
    <div class="ui">
        <div id="round" class="round">Round #1</div>
        <div id="planning" class="planning">Planning Stage: 5s</div>
        <div class="scores" id="scores"></div>
    </div>
    <div class="settings-panel" id="settingsPanel">
        <h3>Game Settings</h3>
        <div class="setting-group">
            <label for="mapJson">Map JSON Data:</label>
            <textarea id="mapJson"
                placeholder='{"title":"Custom Map","author":"Player","dimensions":[64,36],"stars":[[10,10,0],[20,20,1]],"lines":[[0,1]]}'></textarea>
            <div id="mapError" class="error hidden"></div>
        </div>
        <div class="setting-group">
            <label for="moves">Moves per Round:</label>
            <input type="number" id="moves" value="15" min="1" max="50">
        </div>
        <div class="setting-group">
            <label for="rounds">Total Rounds:</label>
            <input type="number" id="rounds" value="10" min="1" max="20">
        </div>
        <div class="setting-group">
            <label for="roundLength">Round Length (seconds):</label>
            <input type="number" id="roundLength" value="30" min="10" max="120">
        </div>
        <div class="setting-group">
            <label for="countdownLength">Planning Stage Length (seconds):</label>
            <input type="number" id="countdownLength" value="5" min="3" max="30">
        </div>
        <div class="setting-group">
            <label for="steals">Steals per Round:</label>
            <input type="number" id="steals" value="15" min="0" max="30">
        </div>
        <div class="setting-group">
            <label for="headquarters">Max Headquarters per Team:</label>
            <input type="number" id="headquarters" value="2" min="1" max="5">
        </div>
        <div class="setting-group">
            <label>Score Multipliers:</label>
            <div class="multiplier-settings">
                <input type="number" id="countMultiplier" class="multiplier-input" value="500" min="0" max="9999"
                    title="Count Multiplier">
                <input type="number" id="distanceMultiplier" class="multiplier-input" value="1" min="0" max="9999"
                    title="Distance Multiplier">
                <input type="number" id="hqMultiplier" class="multiplier-input" value="10" min="0" max="9999"
                    title="HQ Multiplier">
                <input type="number" id="destructionMultiplier" class="multiplier-input" value="1" min="0" max="9999"
                    title="Destruction Multiplier">
            </div>
        </div>
        <div class="setting-group">
            <label>AI Bots:</label>
            <div id="aiBotsList"></div>
            <button class="button" onclick="addAIBot()">Add AI Bot</button>
        </div>
        <div style="text-align:center;margin-top:20px;">
            <button class="button start" onclick="startNewGame()">Start New Game</button>
            <button class="button toggle" onclick="toggleSettings()">Hide Settings</button>
        </div>
    </div>

    <script>
        const T = { N: 0, C: 1, B: 2, W: 3 },
            C = { CY: 0x00FFFF, M: 0xFF00FF, G: 0x00FF00, GOLD: 0xFFD700, BLUE: 0x0000FF, RED: 0xFF0000, DGREEN: 0x006400 },
            J2I = { 1: T.N, 2: T.C, 3: T.W, 4: T.B };
        let MULTIPLIERS = { count: 500, distance: 1, hq: 10, destruction: 1 };

        // Optimized MinHeap for Dijkstra's algorithm
        class MinHeap {
            constructor() {
                this.heap = [];
            }

            insert(item) {
                this.heap.push(item);
                this.heapifyUp(this.heap.length - 1);
            }

            extractMin() {
                if (this.heap.length === 0) return null;
                if (this.heap.length === 1) return this.heap.pop();

                const min = this.heap[0];
                this.heap[0] = this.heap.pop();
                this.heapifyDown(0);
                return min;
            }

            isEmpty() {
                return this.heap.length === 0;
            }

            heapifyUp(index) {
                while (index > 0) {
                    const parentIndex = Math.floor((index - 1) / 2);
                    if (this.heap[parentIndex].dist <= this.heap[index].dist) break;

                    [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]];
                    index = parentIndex;
                }
            }

            heapifyDown(index) {
                while (true) {
                    let minIndex = index;
                    const leftChild = 2 * index + 1;
                    const rightChild = 2 * index + 2;

                    if (leftChild < this.heap.length && this.heap[leftChild].dist < this.heap[minIndex].dist) {
                        minIndex = leftChild;
                    }
                    if (rightChild < this.heap.length && this.heap[rightChild].dist < this.heap[minIndex].dist) {
                        minIndex = rightChild;
                    }

                    if (minIndex === index) break;
                    [this.heap[index], this.heap[minIndex]] = [this.heap[minIndex], this.heap[index]];
                    index = minIndex;
                }
            }
        }

        // Team configuration - easily modifiable for any number of teams
        const TEAM_CONFIGS = [
            { color: C.CY, name: 'cyan', displayName: 'Cyan' },
            { color: C.M, name: 'magenta', displayName: 'Magenta' },
            { color: C.G, name: 'lime', displayName: 'Lime' },
            { color: C.GOLD, name: 'gold', displayName: 'Gold' },
            { color: C.BLUE, name: 'blue', displayName: 'Blue' },
            { color: C.RED, name: 'red', displayName: 'Red' },
            { color: C.DGREEN, name: 'dark green', displayName: 'Dark Green' }
        ];

        // AI Bot Types and Configurations
        const AI_BOT_TYPES = {
            HAL: {
                name: 'HAL',
                description: 'Steady, logical, and dispassionate',
                icon: 'ðŸ¤–',
                strategy: 'defensive'
            },
            CAESAR: {
                name: 'Caesar',
                description: 'Thoughtful and tactical',
                icon: 'ðŸ‘‘',
                strategy: 'tactical'
            },
            ATHENA: {
                name: 'Athena',
                description: 'Hits hard and fast',
                icon: 'âš¡',
                strategy: 'aggressive'
            },
            ROBIN_HOOD: {
                name: 'Robin Hood',
                description: 'Steals from the rich',
                icon: 'ðŸ¹',
                strategy: 'opportunistic'
            },
            EINSTEIN: {
                name: 'Einstein',
                description: 'Loves to study worm-holes',
                icon: 'ðŸ§ ',
                strategy: 'wormhole'
            },
            LORENZ: {
                name: 'Lorenz',
                description: 'An advocate of chaos',
                icon: 'ðŸŒªï¸',
                strategy: 'chaotic'
            }
        };

        // AI Bot Class
        class AIBot {
            constructor(type, teamIndex, aggression = 0.5) {
                this.type = type;
                this.teamIndex = teamIndex;
                this.aggression = Math.max(0, Math.min(1, aggression)); // 0-1 range
                this.config = AI_BOT_TYPES[type];
                this.lastMoveTime = 0;
                this.moveDelay = this.calculateMoveDelay();
                this.hqPlaced = false;
                this.specialStars = new Map(); // Cache special star locations
                this.targetStars = new Set(); // Current targets
                this.lastRoundMoves = 0;
            }

            calculateMoveDelay() {
                // Higher aggression = faster moves (lower delay)
                // Low aggression (0.1) = 2000ms delay, High aggression (1.0) = 100ms delay
                return 2000 - (this.aggression * 1900) + Math.random() * 200;
            }

            shouldMakeMove(currentTime, gameState) {
                if (currentTime - this.lastMoveTime < this.moveDelay) return false;

                // Near end of round, high aggression bots move more frequently
                const timeLeft = gameState.t;
                const roundLength = gameState.RT;
                const timeRatio = timeLeft / roundLength;

                if (timeRatio < 0.3 && this.aggression > 0.7) {
                    // High aggression bots speed up at the end
                    return currentTime - this.lastMoveTime > this.moveDelay * 0.3;
                }

                return true;
            }

            analyzeGameState(game) {
                // Update special stars cache
                this.specialStars.clear();
                game.st.forEach((star, index) => {
                    if (star.ty === T.W) this.specialStars.set(index, 'wormhole');
                    else if (star.ty === T.B) this.specialStars.set(index, 'blackhole');
                    else if (star.ty === T.C) this.specialStars.set(index, 'cluster');
                });

                // Get current team state
                const team = game.tms[this.teamIndex];
                const teamStars = game.st.filter(s => s.tm === this.teamIndex);
                const teamHQs = teamStars.filter(s => s.hq);

                return {
                    team,
                    teamStars,
                    teamHQs,
                    multipliers: MULTIPLIERS,
                    timeLeft: game.t,
                    roundLength: game.RT,
                    stealsLeft: team.st
                };
            }

            makeMove(game) {
                if (!this.shouldMakeMove(Date.now(), game)) return false;

                const gameState = this.analyzeGameState(game);
                let move = null;

                // Strategy-based decision making
                switch (this.config.strategy) {
                    case 'defensive':
                        move = this.defensiveStrategy(game, gameState);
                        break;
                    case 'tactical':
                        move = this.tacticalStrategy(game, gameState);
                        break;
                    case 'aggressive':
                        move = this.aggressiveStrategy(game, gameState);
                        break;
                    case 'opportunistic':
                        move = this.opportunisticStrategy(game, gameState);
                        break;
                    case 'wormhole':
                        move = this.wormholeStrategy(game, gameState);
                        break;
                    case 'chaotic':
                        move = this.chaoticStrategy(game, gameState);
                        break;
                }

                if (move) {
                    this.executeMove(game, move);
                    this.lastMoveTime = Date.now();
                    this.moveDelay = this.calculateMoveDelay();
                    return true;
                }

                return false;
            }

            defensiveStrategy(game, gameState) {
                // HAL: Focus on protecting existing territory and building strong connections
                if (!this.hqPlaced && gameState.teamHQs.length < game.HM) {
                    return this.findBestHQPlacement(game, gameState);
                }

                // Protect valuable stars
                const vulnerableStars = this.findVulnerableStars(game, gameState);
                if (vulnerableStars.length > 0) {
                    return { type: 'capture', target: vulnerableStars[0] };
                }

                // Build defensive connections
                return this.findDefensiveConnection(game, gameState);
            }

            tacticalStrategy(game, gameState) {
                // Caesar: Calculated moves, focus on strategic positions
                if (!this.hqPlaced && gameState.teamHQs.length < game.HM) {
                    return this.findStrategicHQPlacement(game, gameState);
                }

                // Target high-value strategic positions
                const strategicTargets = this.findStrategicTargets(game, gameState);
                if (strategicTargets.length > 0) {
                    return { type: 'capture', target: strategicTargets[0] };
                }

                return this.findTacticalMove(game, gameState);
            }

            aggressiveStrategy(game, gameState) {
                // Athena: Fast expansion and aggressive captures
                const enemyTargets = this.findEnemyTargets(game, gameState);
                if (enemyTargets.length > 0 && gameState.stealsLeft > 0) {
                    return { type: 'steal', target: enemyTargets[0] };
                }

                // Rapid expansion
                const expansionTargets = this.findExpansionTargets(game, gameState);
                if (expansionTargets.length > 0) {
                    return { type: 'capture', target: expansionTargets[0] };
                }

                return null;
            }

            opportunisticStrategy(game, gameState) {
                // Robin Hood: Steal from leading teams, target valuable undefended stars
                const richTargets = this.findRichTargets(game, gameState);
                if (richTargets.length > 0 && gameState.stealsLeft > 0) {
                    return { type: 'steal', target: richTargets[0] };
                }

                // Target undefended valuable stars
                const valuableTargets = this.findValuableUndefendedStars(game, gameState);
                if (valuableTargets.length > 0) {
                    return { type: 'capture', target: valuableTargets[0] };
                }

                return null;
            }

            wormholeStrategy(game, gameState) {
                // Einstein: Focus on wormhole connections and scientific approach
                const wormholes = Array.from(this.specialStars.entries())
                    .filter(([_, type]) => type === 'wormhole')
                    .map(([index, _]) => index);

                if (wormholes.length >= 2) {
                    // Try to connect wormholes
                    const wormholeMove = this.findWormholeConnection(game, gameState, wormholes);
                    if (wormholeMove) return wormholeMove;
                }

                // Fall back to tactical strategy
                return this.tacticalStrategy(game, gameState);
            }

            chaoticStrategy(game, gameState) {
                // Lorenz: Unpredictable moves, disrupt enemy plans
                if (Math.random() < 0.3) {
                    // 30% chance of random disruption
                    const disruptionMove = this.findDisruptionMove(game, gameState);
                    if (disruptionMove) return disruptionMove;
                }

                // Mix of all strategies
                const strategies = ['defensive', 'aggressive', 'opportunistic'];
                const randomStrategy = strategies[Math.floor(Math.random() * strategies.length)];

                switch (randomStrategy) {
                    case 'defensive': return this.defensiveStrategy(game, gameState);
                    case 'aggressive': return this.aggressiveStrategy(game, gameState);
                    case 'opportunistic': return this.opportunisticStrategy(game, gameState);
                }

                return null;
            }

            // Helper methods for move finding
            findBestHQPlacement(game, gameState) {
                const neutralStars = game.st
                    .map((star, index) => ({ star, index }))
                    .filter(({ star }) => star.tm === null && !star.destroyed);

                if (neutralStars.length === 0) return null;

                // Find star with good connectivity and strategic value
                let bestStar = null;
                let bestScore = -1;

                neutralStars.forEach(({ star, index }) => {
                    const connections = game.adjacencyCache[index] || [];
                    const score = connections.length + (star.ty === T.C ? 5 : 0);

                    if (score > bestScore) {
                        bestScore = score;
                        bestStar = index;
                    }
                });

                return bestStar !== null ? { type: 'hq', target: bestStar } : null;
            }

            findVulnerableStars(game, gameState) {
                return game.st
                    .map((star, index) => ({ star, index }))
                    .filter(({ star }) => star.tm === this.teamIndex && !star.hq)
                    .filter(({ index }) => {
                        const connections = game.adjacencyCache[index] || [];
                        const friendlyConnections = connections.filter(connIndex =>
                            game.st[connIndex].tm === this.teamIndex
                        );
                        return friendlyConnections.length <= 1; // Vulnerable if few friendly connections
                    })
                    .map(({ index }) => index);
            }

            findEnemyTargets(game, gameState) {
                return game.st
                    .map((star, index) => ({ star, index }))
                    .filter(({ star }) => star.tm !== null && star.tm !== this.teamIndex && !star.destroyed)
                    .sort((a, b) => {
                        // Prioritize by value: clusters > regular stars, avoid HQs
                        const scoreA = (a.star.ty === T.C ? 10 : 1) - (a.star.hq ? 20 : 0);
                        const scoreB = (b.star.ty === T.C ? 10 : 1) - (b.star.hq ? 20 : 0);
                        return scoreB - scoreA;
                    })
                    .map(({ index }) => index);
            }

            findExpansionTargets(game, gameState) {
                return game.st
                    .map((star, index) => ({ star, index }))
                    .filter(({ star }) => star.tm === null && !star.destroyed)
                    .sort((a, b) => {
                        // Prioritize clusters and well-connected stars
                        const scoreA = (a.star.ty === T.C ? 10 : 1) + (game.adjacencyCache[a.index]?.length || 0);
                        const scoreB = (b.star.ty === T.C ? 10 : 1) + (game.adjacencyCache[b.index]?.length || 0);
                        return scoreB - scoreA;
                    })
                    .map(({ index }) => index);
            }

            findRichTargets(game, gameState) {
                // Target stars owned by leading teams
                const teamScores = game.tms.map((team, index) => ({ team, index, score: team.s }))
                    .sort((a, b) => b.score - a.score);

                const leadingTeams = teamScores.slice(0, 2).map(t => t.index);

                return game.st
                    .map((star, index) => ({ star, index }))
                    .filter(({ star }) => leadingTeams.includes(star.tm) && !star.hq)
                    .map(({ index }) => index);
            }

            findWormholeConnection(game, gameState, wormholes) {
                // Try to create a path between wormholes
                for (let i = 0; i < wormholes.length - 1; i++) {
                    for (let j = i + 1; j < wormholes.length; j++) {
                        const path = this.findPath(game, wormholes[i], wormholes[j]);
                        if (path && path.length > 0) {
                            const nextStar = path.find(starIndex =>
                                game.st[starIndex].tm === null || game.st[starIndex].tm === this.teamIndex
                            );
                            if (nextStar !== undefined) {
                                return { type: 'capture', target: nextStar };
                            }
                        }
                    }
                }
                return null;
            }

            findPath(game, start, end) {
                // Simple pathfinding using adjacency
                const visited = new Set();
                const queue = [[start]];

                while (queue.length > 0) {
                    const path = queue.shift();
                    const current = path[path.length - 1];

                    if (current === end) return path.slice(1); // Exclude start
                    if (visited.has(current)) continue;

                    visited.add(current);
                    const neighbors = game.adjacencyCache[current] || [];

                    for (const neighbor of neighbors) {
                        if (!visited.has(neighbor)) {
                            queue.push([...path, neighbor]);
                        }
                    }
                }

                return null;
            }

            executeMove(game, move) {
                if (!move) return;

                const targetStar = game.st[move.target];
                if (!targetStar || targetStar.destroyed) return;

                let moveExecuted = false;
                let wasSteal = false;

                switch (move.type) {
                    case 'capture':
                        if (targetStar.tm === null) {
                            targetStar.tm = this.teamIndex;
                            moveExecuted = true;
                        }
                        break;
                    case 'steal':
                        if (targetStar.tm !== null && targetStar.tm !== this.teamIndex && game.tms[this.teamIndex].st > 0) {
                            targetStar.tm = this.teamIndex;
                            game.tms[this.teamIndex].st--;
                            moveExecuted = true;
                            wasSteal = true;
                        }
                        break;
                    case 'hq':
                        if (targetStar.tm === null && game.tms[this.teamIndex].h < game.HM) {
                            targetStar.tm = this.teamIndex;
                            targetStar.hq = true;
                            game.tms[this.teamIndex].h++;
                            this.hqPlaced = true;
                            moveExecuted = true;
                        }
                        break;
                }

                if (moveExecuted) {
                    // Add steal visual effect if this was a steal
                    if (wasSteal) {
                        game.addFx(targetStar.x * game.G, targetStar.y * game.G, 'steal');
                    }

                    // Update visuals immediately like player moves do
                    game.drawStar(targetStar, move.target);
                    game.renderConnectedLines(move.target);
                    game.changedTeams.add(this.teamIndex);
                    
                    // Trigger UI updates to refresh steal counters
                    game.deferredScoreUpdate = true;
                    game.needsFullUIUpdate = true;
                }
            }

            // Optimized strategy methods - consolidated to reduce redundancy
            findStrategicHQPlacement(game, gameState) {
                return this.findBestHQPlacement(game, gameState);
            }

            findStrategicTargets(game, gameState) {
                return this.findExpansionTargets(game, gameState);
            }

            findTacticalMove(game, gameState) {
                const targets = this.findExpansionTargets(game, gameState);
                return targets.length > 0 ? { type: 'capture', target: targets[0] } : null;
            }

            findDefensiveConnection(game, gameState) {
                return this.findTacticalMove(game, gameState);
            }

            findValuableUndefendedStars(game, gameState) {
                return this.findExpansionTargets(game, gameState);
            }

            findDisruptionMove(game, gameState) {
                const targets = this.findEnemyTargets(game, gameState);
                return targets.length > 0 && gameState.stealsLeft > 0 ? { type: 'steal', target: targets[0] } : null;
            }
        }

        class Game {
            constructor(s = {}) {
                this.app = new PIXI.Application({
                    width: innerWidth,
                    height: innerHeight,
                    backgroundColor: 0,
                    resolution: devicePixelRatio || 1,
                    autoDensity: true,
                    antialias: true,
                    powerPreference: 'high-performance'
                });
                document.getElementById('gameContainer').appendChild(this.app.view);

                // Update global MULTIPLIERS if provided in settings
                if (s.multipliers) {
                    MULTIPLIERS = { ...MULTIPLIERS, ...s.multipliers };
                }

                Object.assign(this, { G: 20, S: s.steals || 15, HM: s.headquarters || 2, RT: s.roundLength || 30, TR: s.rounds || 10, PT: s.countdownLength || 5, MW: 64, MH: 36 });
                Object.assign(this, { r: 1, t: this.RT, go: false, p: true, pt: this.PT, tm: 0, pu: 0, bhr: 0, ml: false });
                this.st = []; this.ln = []; this.pr = new Set(); this.fx = []; this.cm = s.customMap || null;
                this.wormholeWinner = null; // Track which team won by connecting wormholes

                // Initialize teams based on TEAM_CONFIGS
                this.tms = TEAM_CONFIGS.map(config => ({
                    c: config.color,
                    name: config.name,
                    displayName: config.displayName,
                    s: 0,
                    st: this.S,
                    h: 0,
                    movesLeft: this.S
                }));

                // HQ Connection System - Enhanced for multiple connections
                this.hqConnections = new Map(); // teamId -> Map of connectionId -> { path: [starIndices], distance: number, lastUpdate: timestamp, hqPair: [hqA, hqB] }
                this.hqConnectionPulse = 0; // Animation timer for pulsating effect
                this.usedHQLines = new Map(); // teamId -> Set of line identifiers (starA-starB) to prevent overlap

                // Simple deferred network analysis to prevent lag spikes
                this.deferredNetworkAnalysis = false;
                this.deferredSpecialCheck = false;
                this.deferredScoreUpdate = false;
                this.networkAnalysisTimer = 0;

                // Lag-independent timing for smooth animations
                this.gameStartTime = Date.now();
                this.lastRealTime = Date.now();
                this.roundStartTime = Date.now();

                // Cursor tracking for moves display
                this.cursorPos = { x: 0, y: 0 };
                this.showCursorInfo = false;

                this.c = new PIXI.Container(); this.app.stage.addChild(this.c);
                const g = ['bgGfx', 'destroyedGfx', 'staticLineGfx', 'animatedLineGfx', 'starGfx', 'fxGfx'].map(n => this[n] = new PIXI.Graphics());
                this.llc = new PIXI.Container(); this.tc = new PIXI.Container();
                [this.bgGfx, this.destroyedGfx, this.staticLineGfx, this.animatedLineGfx, this.llc, this.starGfx, this.fxGfx, this.tc].forEach(x => this.c.addChild(x));

                this.cam = { x: 0, y: 0, z: 1 }; this.d = { a: false, sx: 0, sy: 0, cx: 0, cy: 0, m: false };
                this.to = []; this.ti = 0; this.lto = []; this.lti = 0;
                Object.assign(this, { needsStaticLineRedraw: true, needsAnimatedLineRedraw: true, needsStarRedraw: true, needsBgRedraw: true, needsFxRedraw: true, needsDestroyedRedraw: true });
                this.starClickRadius = []; this.lineData = [];
                this.lastStarStates = []; this.lastLineStates = []; this.lastProtectedStars = new Set(); this.lastScores = []; this.lastTeamSteals = [];
                this.mapBounds = { minX: 0, minY: 0, maxX: 0, maxY: 0 };
                this.teamScoreData = [];

                // Cache for performance optimization
                this.adjacencyCache = null;
                this.lastClusterState = new Map(); // Track cluster ownership changes

                // Optimization 1: Spatial indexing for star lookups
                this.spatialGrid = new Map();
                this.gridSize = this.G * 2;

                // Optimization 2: Dirty regions for batch graphics updates
                this.dirtyRegions = new Set();
                this.regionSize = this.G * 4;
                this.dirtyStars = new Set(); // Track individual dirty stars

                // Optimization 3: Compressed state tracking with bit fields
                this.lastStarStateBits = [];

                // Optimization 4: WebGL batch rendering for lines
                this.lineMesh = null;
                this.lineVertices = null;
                this.lineIndices = null;

                // Optimization 5: Optimized score calculation with caching
                this.clusterCache = new Map();
                this.scoreCache = new Array(this.tms.length).fill(0);
                this.changedTeams = new Set();
                this.needsFullUIUpdate = false;

                // AI Bot System
                this.aiBots = s.aiBots || [];
                this.lastAIUpdate = 0;
                this.aiUpdateInterval = 100; // Check AI every 100ms

                this.init();
            }

            init() {
                // Initialize timing for lag-independent animations
                this.gameStartTime = Date.now();
                this.lastRealTime = Date.now();
                this.roundStartTime = Date.now();

                this.loadMap(); this.calculateMapBounds(); this.setupCam(); this.setupEvents(); this.precomputeStaticData(); this.calcScores(); this.updateUI(); this.initStateTracking();
                this.app.ticker.add(dt => this.update(dt));
            }

            calculateMapBounds() {
                if (this.st.length === 0) return;
                let minX = this.st[0].x, maxX = this.st[0].x, minY = this.st[0].y, maxY = this.st[0].y;
                // Use for loop for better performance
                for (let i = 1; i < this.st.length; i++) {
                    const s = this.st[i];
                    if (s.x < minX) minX = s.x;
                    if (s.x > maxX) maxX = s.x;
                    if (s.y < minY) minY = s.y;
                    if (s.y > maxY) maxY = s.y;
                }
                this.mapBounds = { minX: minX - 1, minY: minY - 1, maxX: maxX + 1, maxY: maxY + 1 };
            }

            initStateTracking() {
                this.lastStarStates = this.st.map(s => ({ tm: s.tm, hq: s.hq, pr: s.pr, ful: s.ful ? [...s.ful] : null, req: s.req, destroyed: s.destroyed || false }));
                this.lastLineStates = this.lineData.map((l, i) => ({ connected: this.connected(this.st[l.f], this.st[l.t]), team: this.getLineTeam(l.f, l.t), destroyed: this.ln[i].destroyed || false }));
                this.lastProtectedStars = new Set(this.pr); this.lastScores = this.tms.map(t => t.s); this.lastTeamSteals = this.tms.map(t => t.st);

                // Initialize compressed state tracking
                this.lastStarStateBits = this.st.map(s => this.getStarStateBits(s));
            }

            getLineTeam(f, t) { const a = this.st[f], b = this.st[t]; return a.ty === T.B ? b.tm : b.ty === T.B ? a.tm : a.tm; }

            hasStarStateChanged(i) {
                // Use bit comparison for faster state checking
                const current = this.getStarStateBits(this.st[i]);
                const last = this.lastStarStateBits[i];
                return current !== last;
            }

            hasLineStateChanged(i) {
                const l = this.lineData[i], cc = this.connected(this.st[l.f], this.st[l.t]), ct = this.getLineTeam(l.f, l.t), last = this.lastLineStates[i];
                return cc !== last.connected || ct !== last.team;
            }

            updateStateTracking() {
                this.st.forEach((s, i) => this.lastStarStates[i] = { tm: s.tm, hq: s.hq, pr: s.pr, ful: s.ful ? [...s.ful] : null, req: s.req, destroyed: s.destroyed || false });
                this.lineData.forEach((l, i) => this.lastLineStates[i] = { connected: this.connected(this.st[l.f], this.st[l.t]), team: this.getLineTeam(l.f, l.t), destroyed: this.ln[i].destroyed || false });
                this.lastProtectedStars = new Set(this.pr); this.lastScores = this.tms.map(t => t.s); this.lastTeamSteals = this.tms.map(t => t.st);

                // Update compressed state tracking
                this.lastStarStateBits = this.st.map(s => this.getStarStateBits(s));
            }

            checkStateChanges() {
                let sc = false, lc = false, dc = false;
                for (let i = 0; i < this.st.length && !sc; i++)if (this.hasStarStateChanged(i)) sc = true;
                for (let i = 0; i < this.lineData.length && !lc; i++)if (this.hasLineStateChanged(i)) lc = true;
                if (this.pr.size !== this.lastProtectedStars.size || !Array.from(this.pr).every(x => this.lastProtectedStars.has(x))) sc = lc = true;
                for (let i = 0; i < this.tms.length; i++)if (this.tms[i].s !== this.lastScores[i] || this.tms[i].st !== this.lastTeamSteals[i]) { lc = true; break; }

                // Check for destroyed elements changes
                for (let i = 0; i < this.st.length && !dc; i++) if (this.st[i].destroyed !== (this.lastStarStates[i].destroyed || false)) dc = true;
                for (let i = 0; i < this.ln.length && !dc; i++) if (this.ln[i].destroyed !== (this.lastLineStates[i].destroyed || false)) dc = true;

                if (sc) this.needsStarRedraw = true;
                if (lc) {
                    this.needsStaticLineRedraw = true;
                    this.needsAnimatedLineRedraw = true;
                }
                if (dc) this.needsDestroyedRedraw = true;
                this.updateStateTracking();
            }

            precomputeStaticData() {
                this.starClickRadius = this.st.map(s => (s.ty === T.C ? this.G : this.G / 2) ** 2);
                this.lineData = this.ln.map(l => {
                    const a = this.st[l.f], b = this.st[l.t], x1 = a.x * this.G, y1 = a.y * this.G, x2 = b.x * this.G, y2 = b.y * this.G;
                    const dist = Math.floor(Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)), cx = (x1 + x2) / 2, cy = (y1 + y2) / 2;
                    let dx = x2 - x1, dy = y2 - y1; if (dx < 0) { dx = -dx; dy = -dy; }
                    const ang = Math.atan2(dy, dx); return { x1, y1, x2, y2, dist, cx, cy, ang, pang: ang - Math.PI / 2, f: l.f, t: l.t };
                });

                // Build and cache adjacency list once
                this.buildAdjacencyCache();
                this.initializeClusterState();

                // Build spatial index for fast star lookups
                this.buildSpatialIndex();

                // Initialize WebGL line rendering
                this.initializeLineGraphics();
            }

            buildAdjacencyCache() {
                this.adjacencyCache = new Array(this.st.length).fill(null).map(() => []);
                // Use for loop for better performance
                for (let i = 0; i < this.ln.length; i++) {
                    const l = this.ln[i];
                    this.adjacencyCache[l.f].push(l.t);
                    this.adjacencyCache[l.t].push(l.f);
                }
            }

            // Optimization 1: Spatial indexing for fast star lookups
            buildSpatialIndex() {
                this.spatialGrid.clear();
                // Use for loop for better performance than forEach
                for (let i = 0; i < this.st.length; i++) {
                    const s = this.st[i];
                    const key = `${Math.floor(s.x * this.G / this.gridSize)},${Math.floor(s.y * this.G / this.gridSize)}`;
                    if (!this.spatialGrid.has(key)) this.spatialGrid.set(key, []);
                    this.spatialGrid.get(key).push(i);
                }
            }

            // Optimization 2: Mark regions dirty for batch updates
            markRegionDirty(x, y) {
                const rx = Math.floor(x / this.regionSize);
                const ry = Math.floor(y / this.regionSize);
                this.dirtyRegions.add(`${rx},${ry}`);
            }

            // Mark individual stars as dirty (much faster for single star changes)
            markStarDirty(starIndex) {
                this.dirtyStars.add(starIndex);
            }

            // Ultra-fast line rendering - restored to original efficient behavior
            renderConnectedLines(starIndex) {
                // Simply trigger the efficient line redraw system
                // This is much faster than trying to manually fix individual lines
                this.needsStaticLineRedraw = true;
                this.needsAnimatedLineRedraw = true;
            }

            // Draw a single line with proper styling
            drawSingleLine(l, lineIndex) {
                const line = this.ln[lineIndex];

                // Priority 1: Always render destroyed lines as black on the bottom layer
                if (line && line.destroyed) {
                    this.destroyedGfx.lineStyle(4, 0x000000).moveTo(l.x1, l.y1).lineTo(l.x2, l.y2);
                    return;
                }

                const a = this.st[l.f], b = this.st[l.t];
                let color = 0xFFFFFF, th = 2;

                // Check if protected or HQ connection (animated)
                const isProtected = this.connected(a, b) && (a.pr || b.pr);
                let isHQConnection = false;
                for (const [teamId, connections] of this.hqConnections) {
                    for (const [connectionId, connection] of connections) {
                        if (this.isLineInHQPath(l.f, l.t, connection.path)) {
                            isHQConnection = true;
                            break;
                        }
                    }
                    if (isHQConnection) break;
                }
                const isAnimated = isProtected || isHQConnection;

                if (this.connected(a, b)) {
                    const team = a.ty === T.B ? b.tm : a.tm;
                    if (team !== null) {
                        color = this.tms[team].c;
                        th = 4;
                        if (isProtected) th += (Math.sin(this.pu) + 1) * 1.5;
                        if (isHQConnection) {
                            const hqPulse = (Math.sin(this.hqConnectionPulse) + 1) * 0.5;
                            const teamR = (color >> 16) & 0xFF, teamG = (color >> 8) & 0xFF, teamB = color & 0xFF;
                            color = (Math.round(teamR + (255 - teamR) * hqPulse) << 16) |
                                (Math.round(teamG + (255 - teamG) * hqPulse) << 8) |
                                Math.round(teamB + (255 - teamB) * hqPulse);
                        }
                    }
                }

                (isAnimated ? this.animatedLineGfx : this.staticLineGfx).lineStyle(th, color).moveTo(l.x1, l.y1).lineTo(l.x2, l.y2);
            }

            // Optimization 3: Compressed state tracking with bit manipulation
            getStarStateBits(s) {
                return (s.tm << 0) | (s.hq << 3) | (s.pr << 4) | (s.req << 5) | ((s.ful ? s.ful.length : 0) << 10);
            }

            initializeClusterState() {
                this.lastClusterState.clear();
                for (let i = 0; i < this.st.length; i++) {
                    if (this.st[i].ty === T.C) {
                        this.lastClusterState.set(i, this.st[i].tm);
                    }
                }
            }



            loadMap() {
                if (this.cm) { try { this.loadCustomMap(this.cm); } catch (e) { console.error(e); this.genMap(); } } else this.genMap();
                this.ml = true; this.markAllDirty();
                // Rebuild cache after map changes
                this.buildAdjacencyCache();
                this.initializeClusterState();
                // Rebuild spatial index for new map
                this.buildSpatialIndex();
                // Reinitialize line graphics for new map
                this.initializeLineGraphics();
            }

            loadCustomMap(m) {
                this.st = []; this.ln = []; this.pr.clear();
                if (m.dimensions) { this.MW = m.dimensions[0]; this.MH = m.dimensions[1]; }
                this.tms.forEach((t, i) => {
                    t.st = this.S;
                    t.h = 0;
                    t.movesLeft = this.S;
                    // Mark all teams as changed for score recalculation
                    this.changedTeams.add(i);
                });
                if (m.stars) m.stars.forEach(d => {
                    const it = J2I[d[2]] !== undefined ? J2I[d[2]] : d[2], s = this.makeStar(d[0], d[1], it);
                    if (it === T.W || it === T.B) {
                        if (d.length >= 5) {
                            s.min_value = d[3];
                            s.max_value = d[4];
                        } else if (d.length >= 4) {
                            s.min_value = d[3];
                            s.max_value = d[3];
                        } else {
                            s.min_value = it === T.B ? 2 : 2;
                            s.max_value = it === T.B ? 4 : 3;
                        }
                    }
                    this.st.push(s);
                });
                if (m.lines) m.lines.forEach(d => {
                    let f, t; if (Array.isArray(d)) { f = d[0]; t = d[1]; } else { f = d.from; t = d.to; }
                    if (f < this.st.length && t < this.st.length) this.ln.push({ f, t, destroyed: false, destroyedBy: null, destroyedScore: 0 });
                });
                this.st.forEach(s => {
                    if (s.ty === T.B) {
                        const min = s.min_value || 2, max = s.max_value || 4;
                        s.req = Math.floor(Math.random() * (max - min + 1)) + min;
                        s.ful = [];
                    }
                    else if (s.ty === T.W) {
                        const min = s.min_value || 2, max = s.max_value || 3;
                        s.req = Math.floor(Math.random() * (max - min + 1)) + min;
                    }
                });
            }

            setupCam() {
                const w = (this.mapBounds.maxX - this.mapBounds.minX) * this.G, h = (this.mapBounds.maxY - this.mapBounds.minY) * this.G;
                const z = Math.min(this.app.screen.width / w, this.app.screen.height / h) * 0.8;
                const centerX = this.mapBounds.minX * this.G + w / 2, centerY = this.mapBounds.minY * this.G + h / 2;
                this.cam = { x: this.app.screen.width / 2 - centerX * z, y: this.app.screen.height / 2 - centerY * z, z };
                this.updateCam();
            }
            updateCam() { this.c.x = this.cam.x; this.c.y = this.cam.y; this.c.scale.set(this.cam.z); }

            setupEvents() {
                this.app.stage.eventMode = 'static'; this.app.stage.hitArea = this.app.screen;
                const v = this.app.view, events = [
                    ['mousedown', e => this.onDown(e)], ['mousemove', e => this.onMove(e)], ['mouseup', e => this.onUp(e)],
                    ['wheel', e => this.onWheel(e)], ['contextmenu', e => e.preventDefault()],
                    ['mouseleave', e => this.onMouseLeave(e)],
                    ['touchstart', e => this.onDown(e.touches[0])], ['touchmove', e => { e.preventDefault(); this.onMove(e.touches[0]); }],
                    ['touchend', e => this.onUp(e.changedTouches[0])]
                ]; events.forEach(([n, h]) => v.addEventListener(n, h));

                // Add global mouse up listener to catch mouse up events outside the canvas
                document.addEventListener('mouseup', (e) => {
                    if (this.d.a) {
                        this.d.a = false;
                        this.d.m = false;
                    }
                });

                // Add global mouse leave listener for additional safety
                document.addEventListener('mouseleave', (e) => {
                    if (this.d.a) {
                        this.d.a = false;
                        this.d.m = false;
                    }
                });
            }

            onDown(e) {
                if (e.button && e.button !== 0 && e.button !== 2) return;
                const x = e.clientX || e.pageX, y = e.clientY || e.pageY;
                this.d = { a: true, sx: x, sy: y, cx: this.cam.x, cy: this.cam.y, m: false, b: e.button };
            }
            onMove(e) {
                const x = e.clientX || e.pageX, y = e.clientY || e.pageY;

                // Update cursor position for moves display
                this.cursorPos = { x, y };
                this.showCursorInfo = !this.p && !this.go;

                if (!this.d.a) return;
                const dx = x - this.d.sx, dy = y - this.d.sy;
                if (Math.abs(dx) > 3 || Math.abs(dy) > 3) this.d.m = true;
                this.cam.x = this.d.cx + dx; this.cam.y = this.d.cy + dy;
                this.updateCam();
            }
            onUp(e) {
                if (!this.d.a) return;
                if (!this.d.m && this.ml) {
                    const x = e.clientX || e.pageX, y = e.clientY || e.pageY, wx = (x - this.cam.x) / this.cam.z, wy = (y - this.cam.y) / this.cam.z;
                    if (this.d.b === 2) this.addFx(wx, wy, 'pointer');
                    else if (!this.p && !this.go) { const s = this.findStar({ x: wx, y: wy }); if (s !== -1) this.clickStar(s); }
                }
                this.d.a = this.d.m = false;
            }
            onWheel(e) {
                e.preventDefault(); const f = e.deltaY > 0 ? 0.9 : 1.1, nz = Math.max(0.2, Math.min(3, this.cam.z * f));
                if (nz === this.cam.z) return; const mx = e.clientX, my = e.clientY, wx = (mx - this.cam.x) / this.cam.z, wy = (my - this.cam.y) / this.cam.z;
                this.cam.z = nz; this.cam.x = mx - wx * nz; this.cam.y = my - wy * nz; this.updateCam();
            }

            onMouseLeave(e) {
                this.showCursorInfo = false;
                const existing = document.getElementById('cursorInfo');
                if (existing) existing.remove();

                // Reset drag state to prevent camera getting stuck
                this.d.a = false;
                this.d.m = false;
            }

            setupScoreboardEvents() {
                // This will be called after the scoreboard is created
                setTimeout(() => {
                    const scoresEl = document.getElementById('scores');
                    if (scoresEl) {
                        // Remove any existing handlers to prevent duplicates
                        scoresEl.removeAttribute('data-team-click-handler');
                        const newScoresEl = scoresEl.cloneNode(true);
                        scoresEl.parentNode.replaceChild(newScoresEl, scoresEl);

                        // Add fresh event handler
                        newScoresEl.addEventListener('click', (e) => {
                            // Check if clicking on a team row
                            const scoreRow = e.target.closest('.score-row');
                            if (scoreRow && !scoreRow.classList.contains('multiplier-row')) {
                                const teamIndex = parseInt(scoreRow.getAttribute('data-team-index'));

                                if (!isNaN(teamIndex) && teamIndex >= 0 && teamIndex < this.tms.length) {
                                    this.tm = teamIndex;
                                    // Force immediate leaderboard visual update
                                    this.needsFullUIUpdate = true;
                                    this.updateUI();
                                    e.stopPropagation();
                                    return;
                                }
                            }

                            // Toggle expanded view if not clicking on team
                            newScoresEl.classList.toggle('expanded');
                        });
                        newScoresEl.setAttribute('data-team-click-handler', 'true');
                    }
                }, 100);
            }

            addFx(x, y, ty) {
                const currentTime = Date.now() / 1000;
                this.fx.push({
                    x, y, ty,
                    startTime: currentTime,
                    mt: ty === 'steal' ? 0.8 : 0.6
                });
                this.needsFxRedraw = true;
            }

            updateFx(dt) {
                const currentTime = Date.now() / 1000;
                const pl = this.fx.length;

                // Use real-time for lag-independent steal animations
                this.fx = this.fx.filter(e => {
                    if (e.type === 'blackhole_destruction') {
                        // Handle blackhole destruction particles
                        return e.life > 0;
                    } else {
                        // Handle regular effects
                        const elapsed = currentTime - e.startTime;
                        e.t = elapsed; // Update progress based on real time
                        return elapsed < e.mt;
                    }
                });

                if (this.fx.length || pl !== this.fx.length) this.needsFxRedraw = true;
            }

            getText(tx, x, y, st) {
                if (this.ti >= this.to.length) { const t = new PIXI.Text('', st); t.anchor.set(0.5); this.to.push(t); this.tc.addChild(t); }
                const t = this.to[this.ti++]; Object.assign(t, { text: tx, x, y, style: st, visible: true }); return t;
            }
            getLineText(tx, x, y, st) {
                if (this.lti >= this.lto.length) { const t = new PIXI.Text('', st); t.anchor.set(0.5); this.lto.push(t); this.llc.addChild(t); }
                const t = this.lto[this.lti++]; Object.assign(t, { text: tx, x, y, style: st, visible: true }); return t;
            }
            resetText() { this.to.forEach(t => t.visible = false); this.ti = 0; this.lto.forEach(t => t.visible = false); this.lti = 0; }

            genMap() {
                this.st = []; this.ln = []; this.pr.clear();
                this.tms.forEach((t, i) => {
                    t.st = this.S;
                    t.h = 0;
                    t.movesLeft = this.S;
                    // Mark all teams as changed for score recalculation
                    this.changedTeams.add(i);
                });

                for (let i = 0; i < 35; i++)this.st.push(this.makeStar(Math.random() * this.MW, Math.random() * this.MH, Math.random() < 0.2 ? T.C : T.N));
                for (let i = 0; i < 5; i++) { const s = this.makeStar(Math.random() * this.MW, Math.random() * this.MH, T.B); s.req = Math.floor(Math.random() * 3) + 2; s.ful = []; this.st.push(s); }
                for (let i = 0; i < 3; i++) { const s = this.makeStar(Math.random() * this.MW, Math.random() * this.MH, T.W); s.req = Math.floor(Math.random() * 2) + 2; this.st.push(s); }
                for (let i = 0; i < this.st.length; i++)for (let j = i + 1; j < this.st.length; j++)if (Math.random() < 0.2) this.ln.push({ f: i, t: j, destroyed: false, destroyedBy: null, destroyedScore: 0 });
            }
            makeStar(x, y, ty) { return { x, y, tm: null, hq: false, ty, pr: false, destroyed: false, destroyedBy: null, destroyedScore: 0 }; }

            // Calculate score for destroying elements (simple count)
            calculateDestroyedScore() { return 1; }

            // Optimized star finding using spatial indexing
            findStar(pos) {
                const gx = Math.floor(pos.x / this.gridSize);
                const gy = Math.floor(pos.y / this.gridSize);

                // Check 9 cells (current + 8 neighbors) for maximum efficiency
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const candidates = this.spatialGrid.get(`${gx + dx},${gy + dy}`);
                        if (candidates) {
                            for (const i of candidates) {
                                const s = this.st[i];
                                const deltaX = pos.x - s.x * this.G, deltaY = pos.y - s.y * this.G;
                                if (deltaX * deltaX + deltaY * deltaY <= this.starClickRadius[i]) return i;
                            }
                        }
                    }
                }
                return -1;
            }

            clickStar(i) {
                const s = this.st[i];
                if (s.ty === T.B) return;
                if (s.destroyed) return; // Can't reclaim destroyed stars

                // Check if current team has moves left
                if (this.tms[this.tm].movesLeft <= 0) return;

                // Can't use moves on stars already owned by same team
                if (s.tm === this.tm) return;

                let stolen = false;
                if (s.tm !== null && s.tm !== this.tm) {
                    if (s.hq || s.pr || this.tms[this.tm].st <= 0) return;
                    this.tms[this.tm].st--;
                    this.tms[this.tm].movesLeft--;
                    s.tm = this.tm;
                    stolen = true;
                } else {
                    s.tm = this.tm;
                    this.tms[this.tm].movesLeft--;
                }

                // First X moves should be HQs regardless of whether they're steals or regular claims
                if (this.tms[this.tm].h < this.HM) {
                    s.hq = true;
                    this.tms[this.tm].h++;
                }

                if (stolen) this.addFx(s.x * this.G, s.y * this.G, 'steal');

                // INSTANT VISUAL UPDATES - no delays

                // 1. Immediately redraw just this star (ultra-fast)
                this.drawStar(s, i);

                // 2. Immediately redraw connected lines (fast)
                this.renderConnectedLines(i);

                // 3. Update header immediately
                this.updateHeader();

                // 4. Mark team as changed for later score calculation
                this.changedTeams.add(this.tm);
                if (stolen && s.tm !== null) this.changedTeams.add(s.tm);

                // Defer score calculation and full UI update
                this.deferredScoreUpdate = true;
                this.deferredNetworkAnalysis = true;
                this.deferredSpecialCheck = true;
                this.networkAnalysisTimer = 0;
            }

            update(dt) {
                // Use real-time for lag-independent animations
                const currentTime = Date.now();
                const realDt = (currentTime - this.lastRealTime) / 1000;
                this.lastRealTime = currentTime;

                // Frame-dependent dt for game logic (can lag)
                dt /= 60;

                if (this.p) {
                    // Use real-time for smooth planning countdown
                    const elapsedTime = (currentTime - this.gameStartTime) / 1000;
                    const remainingTime = Math.max(0, this.PT - elapsedTime);
                    const newPt = Math.ceil(remainingTime);

                    // Only update planning text if the displayed seconds changed
                    if (!this.lastPlanningTime || this.lastPlanningTime !== newPt) {
                        document.getElementById('planning').textContent = `Planning Stage: ${newPt}s`;
                        this.lastPlanningTime = newPt;
                    }

                    if (remainingTime <= 0) this.startGame();
                } else if (!this.go) {
                    // Use real-time for ultra-smooth timer bar
                    const elapsedTime = (currentTime - this.roundStartTime) / 1000;
                    const remainingTime = Math.max(0, this.RT - elapsedTime);
                    const newWidth = (remainingTime / this.RT) * 100;

                    // Update timer bar every frame for maximum smoothness
                    const te = document.getElementById('timer');
                    te.style.width = `${newWidth.toFixed(2)}%`;

                    if (remainingTime <= 0) this.nextRound();
                }

                // Use real-time for smooth animations (lag-independent)
                const animTime = currentTime / 1000;
                this.pu = animTime * 3;  // Match HQ connection speed
                this.bhr = animTime * 0.5;
                this.hqConnectionPulse = animTime * 3;

                // Use frame-dependent dt for effects (can lag, but less critical)
                this.updateFx(dt);

                // Handle deferred expensive operations to prevent lag spikes
                if (this.deferredScoreUpdate || this.deferredNetworkAnalysis || this.deferredSpecialCheck) {
                    this.networkAnalysisTimer += dt;
                    // Wait 50ms for score update, 150ms for heavy operations
                    if (this.networkAnalysisTimer > 0.05 && this.deferredScoreUpdate) {
                        this.calcScoresIncremental();
                        this.updateUI();
                        this.deferredScoreUpdate = false;
                    }
                }

                // Update AI bots
                this.updateAIBots(currentTime);

                if (this.deferredScoreUpdate || this.deferredNetworkAnalysis || this.deferredSpecialCheck) {
                    if (this.networkAnalysisTimer > 0.15) {
                        if (this.deferredNetworkAnalysis) {
                            this.updateProtection();
                            this.deferredNetworkAnalysis = false;
                        }
                        if (this.deferredSpecialCheck) {
                            this.checkSpecialOptimized();
                            const wormholeWinner = this.checkWormholeOptimized();
                            if (wormholeWinner !== false) {
                                this.wormholeWinner = wormholeWinner;
                                this.needsFullUIUpdate = true;
                                this.updateScoreDisplay(); // Update scores first
                                this.go = true;
                                this.updateUI();
                            }
                            this.deferredSpecialCheck = false;
                        }
                        this.networkAnalysisTimer = 0;
                    }
                }

                // Optimized animation checking - consolidate redundant checks
                let hasAnimations = this.fx.length > 0;
                let hasProtectedOrHQ = this.pr.size > 0 || this.hasAnyHQConnections();
                let hasBlackHoleAnimation = false;

                // Check for black hole animation only when needed
                if (!hasAnimations) {
                    for (let i = 0; i < this.st.length; i++) {
                        if (this.st[i].ty === T.B && this.st[i].ful && this.st[i].ful.length > 0) {
                            hasBlackHoleAnimation = true;
                            break;
                        }
                    }
                }

                // Set redraw flags based on animation state
                if (hasAnimations) this.needsFxRedraw = true;
                if (hasProtectedOrHQ) this.needsAnimatedLineRedraw = true;
                if (hasBlackHoleAnimation) this.needsStarRedraw = true;

                // Optimized rendering - only render what's needed
                if (this.needsBgRedraw) { this.renderBackground(); this.needsBgRedraw = false; }
                if (this.needsDestroyedRedraw) { this.renderDestroyed(); this.needsDestroyedRedraw = false; }
                if (this.needsStaticLineRedraw) { this.renderStaticLines(); this.needsStaticLineRedraw = false; }
                if (this.needsAnimatedLineRedraw) { this.renderAnimatedLines(); this.needsAnimatedLineRedraw = false; }
                if (this.needsStarRedraw || this.dirtyRegions.size > 0 || this.dirtyStars.size > 0) { this.renderStars(); this.needsStarRedraw = false; }
                if (this.needsFxRedraw) { this.renderFx(); this.needsFxRedraw = false; }

                // Update cursor info display
                this.updateCursorDisplay();
            }

            markAllDirty() {
                this.needsBgRedraw = this.needsStaticLineRedraw = this.needsAnimatedLineRedraw = this.needsStarRedraw = this.needsFxRedraw = this.needsDestroyedRedraw = true;
            }

            startGame() {
                this.p = false; document.getElementById('planning').style.display = 'none'; document.getElementById('timer').style.display = 'block';
                this.st.forEach(s => { if (s.ty >= T.B && s.req === undefined) s.req = Math.floor(Math.random() * 3) + 2; });

                // Reset timing for smooth round timer
                this.roundStartTime = Date.now();

                // Mark all teams as changed for initial score calculation
                for (let i = 0; i < this.tms.length; i++) {
                    this.changedTeams.add(i);
                }

                this.needsStarRedraw = true;
                this.initStateTracking();
                this.calcScoresIncremental();
            }
            nextRound() {
                this.r++;
                if (this.r > this.TR) {
                    this.go = true;
                    this.needsFullUIUpdate = true;
                    this.updateUI();
                    return;
                }
                this.t = this.RT;
                // Reset timing for smooth next round timer
                this.roundStartTime = Date.now();
                // Instantly reset timer width to 100% without transition
                const timerEl = document.getElementById('timer');
                timerEl.style.width = '100%';

                this.tms.forEach((t, i) => {
                    t.st = this.S;
                    t.movesLeft = this.S;
                    // Mark all teams as changed for score recalculation
                    this.changedTeams.add(i);
                });
                // Only recalculate scores if there are changes
                if (this.changedTeams.size > 0) {
                    this.calcScoresIncremental();
                }
                // Only update UI if scores actually changed
                this.needsFullUIUpdate = true;
                this.updateUI();
                this.checkStateChanges();
            }

            calcScores() {
                this.tms.forEach(t => t.s = 0);
                this.teamScoreData = this.tms.map((team, idx) => ({
                    team, teamIdx: idx, count: 0, distance: 0, hqDistance: 0, destruction: 0, steals: team.st
                }));

                this.lineData.forEach(l => {
                    const a = this.st[l.f], b = this.st[l.t];
                    if (this.connected(a, b)) {
                        const team = a.ty === T.B ? b.tm : a.tm;
                        if (team !== null) {
                            const dist = Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2) * this.G;
                            this.teamScoreData[team].count++;
                            this.teamScoreData[team].distance += dist;
                            this.tms[team].s += dist;
                        }
                    }
                });

                // Add destroyed element scores
                for (let team = 0; team < this.tms.length; team++) {
                    let destructionScore = 0;

                    // Score from destroyed stars
                    for (const star of this.st) {
                        if (star.destroyedBy === team) {
                            destructionScore += star.destroyedScore;
                        }
                    }

                    // Score from destroyed lines
                    for (const line of this.ln) {
                        if (line.destroyedBy === team) {
                            destructionScore += line.destroyedScore;
                        }
                    }

                    this.teamScoreData[team].destruction = destructionScore;
                    this.tms[team].s += destructionScore;
                }

                this.teamScoreData.forEach(data => {
                    // Calculate HQ connection bonus using the enhanced system
                    const hqConnectionScore = this.getHQConnectionScore(data.teamIdx);
                    data.hqDistance = hqConnectionScore;

                    // Apply multiplier to HQ score for final score calculation, but keep raw value for display
                    data.finalScore = Math.round(data.count * MULTIPLIERS.count + data.distance * MULTIPLIERS.distance + data.hqDistance * MULTIPLIERS.hq + data.destruction * MULTIPLIERS.destruction);
                    data.count = Math.round(data.count); data.distance = Math.round(data.distance); data.hqDistance = Math.round(data.hqDistance); data.destruction = Math.round(data.destruction);
                });

                // Update score cache
                this.tms.forEach((t, i) => this.scoreCache[i] = t.s);
                this.changedTeams.clear();
            }

            // Optimization 5: Incremental score calculation
            calcScoresIncremental() {
                // Only recalculate scores for teams with changes
                if (this.changedTeams.size === 0) return;

                // If too many teams changed, fall back to full calculation
                if (this.changedTeams.size > this.tms.length / 2) {
                    this.calcScores();
                    return;
                }

                // Recalculate only changed teams
                this.changedTeams.forEach(teamId => {
                    if (teamId >= 0 && teamId < this.tms.length) {
                        this.scoreCache[teamId] = this.calculateTeamScore(teamId);
                        this.tms[teamId].s = this.scoreCache[teamId];
                    }
                });

                // Update team score data for changed teams - use cached scores to avoid line iteration
                this.changedTeams.forEach(teamId => {
                    if (teamId >= 0 && teamId < this.teamScoreData.length) {
                        const data = this.teamScoreData[teamId];

                        // Use cached score instead of recalculating from lines
                        data.distance = this.scoreCache[teamId];

                        // Calculate destruction score
                        let destructionScore = 0;
                        for (const star of this.st) {
                            if (star.destroyedBy === teamId) {
                                destructionScore += star.destroyedScore;
                            }
                        }
                        for (const line of this.ln) {
                            if (line.destroyedBy === teamId) {
                                destructionScore += line.destroyedScore;
                            }
                        }
                        data.destruction = destructionScore;

                        // Estimate count based on distance (rough approximation for UI)
                        data.count = Math.round(data.distance / (this.G * 10)); // Rough estimate

                        const hqConnectionScore = this.getHQConnectionScore(teamId);
                        data.hqDistance = hqConnectionScore;
                        data.finalScore = Math.round(data.count * MULTIPLIERS.count + data.distance * MULTIPLIERS.distance + data.hqDistance * MULTIPLIERS.hq + data.destruction * MULTIPLIERS.destruction);
                        data.count = Math.round(data.count);
                        data.distance = Math.round(data.distance);
                        data.hqDistance = Math.round(data.hqDistance);
                        data.destruction = Math.round(data.destruction);
                    }
                });

                this.changedTeams.clear();
            }

            calculateTeamScore(teamId) {
                let score = 0;
                // Use for loop for better performance
                for (let i = 0; i < this.lineData.length; i++) {
                    const l = this.lineData[i];
                    const a = this.st[l.f], b = this.st[l.t];
                    if (this.connected(a, b)) {
                        const team = a.ty === T.B ? b.tm : a.tm;
                        if (team === teamId) {
                            const dist = Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2) * this.G;
                            score += dist;
                        }
                    }
                }

                // Add destruction scores
                for (const star of this.st) {
                    if (star.destroyedBy === teamId) {
                        score += star.destroyedScore;
                    }
                }
                for (const line of this.ln) {
                    if (line.destroyedBy === teamId) {
                        score += line.destroyedScore;
                    }
                }

                return score;
            }

            // Ultra-fast incremental score update - only recalculate affected lines
            calculateTeamScoreFast(teamId, changedStarIndex) {
                // Start with cached score
                let score = this.scoreCache[teamId] || 0;

                // Only check lines connected to the changed star
                const neighbors = this.adjacencyCache[changedStarIndex];
                for (let i = 0; i < neighbors.length; i++) {
                    const neighborIndex = neighbors[i];
                    const lineIndex = this.findLineIndex(changedStarIndex, neighborIndex);
                    if (lineIndex !== -1) {
                        const l = this.lineData[lineIndex];
                        const a = this.st[l.f], b = this.st[l.t];
                        if (this.connected(a, b)) {
                            const team = a.ty === T.B ? b.tm : a.tm;
                            if (team === teamId) {
                                const dist = Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2) * this.G;
                                // This is a rough approximation - for exact calculation use full method
                                score += dist * 0.1; // Small incremental change
                            }
                        }
                    }
                }
                return score;
            }

            findLineIndex(starA, starB) {
                // Quick lookup for line between two stars
                for (let i = 0; i < this.lineData.length; i++) {
                    const l = this.lineData[i];
                    if ((l.f === starA && l.t === starB) || (l.f === starB && l.t === starA)) {
                        return i;
                    }
                }
                return -1;
            }

            connected(a, b) { return a.ty === T.B ? b.tm !== null : b.ty === T.B ? a.tm !== null : a.tm !== null && a.tm === b.tm; }

            updateProtection() {
                // Clear previous protection state
                this.pr.clear();
                this.st.forEach(s => s.pr = false);

                // Use unified network analysis for both protection and HQ connections
                this.analyzeTeamNetworks();

                // Trigger redraw of both static and animated lines when network changes
                this.needsStaticLineRedraw = true;
                this.needsAnimatedLineRedraw = true;
            }

            // Unified network analysis system - simple and reliable
            analyzeTeamNetworks() {
                // Single pass through all stars to group by team
                const teamStars = new Map();
                const teamClusters = new Map();
                const teamHQs = new Map();

                for (let i = 0; i < this.st.length; i++) {
                    const s = this.st[i];
                    if (s.tm !== null) {
                        // Group all stars by team
                        if (!teamStars.has(s.tm)) {
                            teamStars.set(s.tm, []);
                            teamClusters.set(s.tm, []);
                            teamHQs.set(s.tm, []);
                        }
                        teamStars.get(s.tm).push(i);

                        // Track clusters and HQs
                        if (s.ty === T.C) teamClusters.get(s.tm).push(i);
                        if (s.hq) teamHQs.get(s.tm).push(i);
                    }
                }

                // Process each team's network once
                teamStars.forEach((stars, teamId) => {
                    this.processTeamNetwork(teamId, stars, teamClusters.get(teamId), teamHQs.get(teamId));
                });


            }

            processTeamNetwork(teamId, allStars, clusterStars, hqStars) {
                // Build team-specific adjacency for faster lookups
                const teamAdjacency = this.buildTeamAdjacency(allStars, teamId);

                // Process cluster protection using optimized BFS
                if (clusterStars.length > 0) {
                    this.processClusterProtection(clusterStars, teamAdjacency);
                }

                // Process HQ connections using enhanced modular system
                if (hqStars.length >= 2) {
                    this.processModularHQConnections(teamId, hqStars, teamAdjacency);
                } else {
                    this.hqConnections.delete(teamId);
                    this.usedHQLines.delete(teamId);
                }
            }

            // Optimization 4: WebGL batch rendering initialization
            initializeLineGraphics() {
                if (this.ln.length === 0) return;

                // Create vertices array (4 vertices per line, 2 coords each)
                this.lineVertices = new Float32Array(this.ln.length * 4 * 2);

                // Create indices array (2 triangles per line)
                this.lineIndices = new Uint16Array(this.ln.length * 6);

                // Setup indices (same for all lines)
                this.ln.forEach((l, i) => {
                    const base = i * 6;
                    const vBase = i * 4;
                    this.lineIndices[base] = vBase;
                    this.lineIndices[base + 1] = vBase + 1;
                    this.lineIndices[base + 2] = vBase + 2;
                    this.lineIndices[base + 3] = vBase;
                    this.lineIndices[base + 4] = vBase + 2;
                    this.lineIndices[base + 5] = vBase + 3;
                });

                // Update line vertices
                this.updateLineVertices();
            }

            updateLineVertices() {
                if (!this.lineVertices) return;

                // Use for loop for maximum performance in critical path
                const thickness = 2;
                for (let i = 0; i < this.lineData.length; i++) {
                    const l = this.lineData[i];
                    const dx = l.x2 - l.x1;
                    const dy = l.y2 - l.y1;
                    const length = Math.sqrt(dx * dx + dy * dy);

                    if (length === 0) continue;

                    const nx = -dy / length * thickness;
                    const ny = dx / length * thickness;

                    const base = i * 8; // 4 vertices * 2 coords

                    // Vertex 0
                    this.lineVertices[base] = l.x1 + nx;
                    this.lineVertices[base + 1] = l.y1 + ny;

                    // Vertex 1
                    this.lineVertices[base + 2] = l.x1 - nx;
                    this.lineVertices[base + 3] = l.y1 - ny;

                    // Vertex 2
                    this.lineVertices[base + 4] = l.x2 - nx;
                    this.lineVertices[base + 5] = l.y2 - ny;

                    // Vertex 3
                    this.lineVertices[base + 6] = l.x2 + nx;
                    this.lineVertices[base + 7] = l.y2 + ny;
                }
            }

            buildTeamAdjacency(teamStars, teamId) {
                const teamAdjacency = new Map();

                // Initialize adjacency for team stars only
                teamStars.forEach(starId => {
                    teamAdjacency.set(starId, []);
                });

                // Build adjacency list for this team only
                teamStars.forEach(starId => {
                    for (const neighbor of this.adjacencyCache[starId]) {
                        if (this.st[neighbor].tm === teamId) {
                            teamAdjacency.get(starId).push(neighbor);
                        }
                    }
                });

                return teamAdjacency;
            }

            processClusterProtection(clusterStars, teamAdjacency) {
                const globalProcessed = new Set();

                for (const startStar of clusterStars) {
                    if (!globalProcessed.has(startStar)) {
                        this.expandProtectionNetwork(startStar, teamAdjacency, globalProcessed);
                    }
                }
            }

            expandProtectionNetwork(start, teamAdjacency, globalProcessed) {
                // Optimized BFS using array as queue (faster than shift())
                const queue = [start];
                let queueIndex = 0;
                const visited = new Set([start]);

                while (queueIndex < queue.length) {
                    const current = queue[queueIndex++];

                    globalProcessed.add(current);
                    this.st[current].pr = true;
                    this.pr.add(current);

                    // Add unvisited neighbors to queue
                    for (const neighbor of teamAdjacency.get(current)) {
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                            queue.push(neighbor);
                        }
                    }
                }
            }

            processModularHQConnections(teamId, hqStars, teamAdjacency) {
                // Initialize team connections if not exists
                if (!this.hqConnections.has(teamId)) {
                    this.hqConnections.set(teamId, new Map());
                }
                if (!this.usedHQLines.has(teamId)) {
                    this.usedHQLines.set(teamId, new Set());
                }

                const teamConnections = this.hqConnections.get(teamId);
                const usedLines = this.usedHQLines.get(teamId);

                // Remove broken connections and their used lines
                for (const [connectionId, connection] of teamConnections) {
                    if (this.isConnectionBroken(connection, teamId)) {
                        // Remove used lines for this broken connection
                        this.removeUsedLinesForConnection(connection, usedLines);
                        teamConnections.delete(connectionId);
                    }
                }

                // Generate all possible HQ pairs
                const hqPairs = [];
                for (let i = 0; i < hqStars.length; i++) {
                    for (let j = i + 1; j < hqStars.length; j++) {
                        hqPairs.push([hqStars[i], hqStars[j]]);
                    }
                }

                // Try to establish connections for each pair
                for (const [hqA, hqB] of hqPairs) {
                    const connectionId = this.getConnectionId(hqA, hqB);

                    // Skip if connection already exists and is valid
                    if (teamConnections.has(connectionId)) continue;

                    // Find path between this HQ pair
                    const path = this.findShortestPath(hqA, hqB, teamAdjacency);
                    if (!path) continue;

                    // Check if this path would overlap with existing HQ lines
                    if (this.wouldPathOverlap(path.path, usedLines)) {
                        // Try to find alternative path that doesn't overlap
                        const altPath = this.findAlternativeHQPath(hqA, hqB, teamAdjacency, usedLines);
                        if (altPath && !this.wouldPathOverlap(altPath.path, usedLines)) {
                            // Use alternative path
                            this.addHQConnection(teamId, connectionId, altPath, [hqA, hqB], usedLines);
                        }
                    } else {
                        // Direct path is clear, use it
                        this.addHQConnection(teamId, connectionId, path, [hqA, hqB], usedLines);
                    }
                }

                // Clean up if no connections remain
                if (teamConnections.size === 0) {
                    this.hqConnections.delete(teamId);
                    this.usedHQLines.delete(teamId);
                }
            }

            // Helper functions for modular HQ system
            getConnectionId(hqA, hqB) {
                // Create consistent connection ID regardless of order
                return hqA < hqB ? `${hqA}-${hqB}` : `${hqB}-${hqA}`;
            }

            getLineId(starA, starB) {
                // Create consistent line ID regardless of order
                return starA < starB ? `${starA}-${starB}` : `${starB}-${starA}`;
            }

            addHQConnection(teamId, connectionId, path, hqPair, usedLines) {
                const teamConnections = this.hqConnections.get(teamId);

                // Add the connection
                teamConnections.set(connectionId, {
                    path: path.path,
                    distance: path.distance,
                    lastUpdate: Date.now(),
                    hqPair: hqPair
                });

                // Mark lines as used
                for (let i = 0; i < path.path.length - 1; i++) {
                    const lineId = this.getLineId(path.path[i], path.path[i + 1]);
                    usedLines.add(lineId);
                }
            }

            removeUsedLinesForConnection(connection, usedLines) {
                for (let i = 0; i < connection.path.length - 1; i++) {
                    const lineId = this.getLineId(connection.path[i], connection.path[i + 1]);
                    usedLines.delete(lineId);
                }
            }

            wouldPathOverlap(path, usedLines) {
                for (let i = 0; i < path.length - 1; i++) {
                    const lineId = this.getLineId(path[i], path[i + 1]);
                    if (usedLines.has(lineId)) {
                        return true;
                    }
                }
                return false;
            }

            findAlternativeHQPath(startIndex, endIndex, teamAdjacency, usedLines) {
                // Modified Dijkstra that avoids used lines
                const distances = new Map();
                const previous = new Map();
                const heap = new MinHeap();

                // Initialize distances
                for (const starId of teamAdjacency.keys()) {
                    distances.set(starId, Infinity);
                }
                distances.set(startIndex, 0);
                heap.insert({ id: startIndex, dist: 0 });

                while (!heap.isEmpty()) {
                    const { id: current, dist: currentDist } = heap.extractMin();

                    if (current === endIndex) break;
                    if (currentDist > distances.get(current)) continue;

                    for (const neighbor of teamAdjacency.get(current)) {
                        // Skip if this line is already used (unless it's the start or end HQ)
                        const lineId = this.getLineId(current, neighbor);
                        if (usedLines.has(lineId) && current !== startIndex && neighbor !== endIndex) {
                            continue;
                        }

                        const edgeWeight = this.getStarDistance(current, neighbor);
                        const newDistance = currentDist + edgeWeight;

                        if (newDistance < distances.get(neighbor)) {
                            distances.set(neighbor, newDistance);
                            previous.set(neighbor, current);
                            heap.insert({ id: neighbor, dist: newDistance });
                        }
                    }
                }

                // Reconstruct path
                if (distances.get(endIndex) === Infinity) return null;

                const path = [];
                let current = endIndex;
                while (current !== undefined) {
                    path.unshift(current);
                    current = previous.get(current);
                }

                return {
                    path: path,
                    distance: distances.get(endIndex) * this.G
                };
            }

            hasAnyHQConnections() {
                for (const [teamId, connections] of this.hqConnections) {
                    if (connections.size > 0) return true;
                }
                return false;
            }

            findShortestPath(startIndex, endIndex, teamAdjacency) {
                // Optimized Dijkstra using binary heap for priority queue
                const distances = new Map();
                const previous = new Map();
                const heap = new MinHeap();

                // Initialize distances
                for (const starId of teamAdjacency.keys()) {
                    distances.set(starId, Infinity);
                }
                distances.set(startIndex, 0);
                heap.insert({ id: startIndex, dist: 0 });

                while (!heap.isEmpty()) {
                    const { id: current, dist: currentDist } = heap.extractMin();

                    if (current === endIndex) break;
                    if (currentDist > distances.get(current)) continue;

                    for (const neighbor of teamAdjacency.get(current)) {
                        const edgeWeight = this.getStarDistance(current, neighbor);
                        const newDistance = currentDist + edgeWeight;

                        if (newDistance < distances.get(neighbor)) {
                            distances.set(neighbor, newDistance);
                            previous.set(neighbor, current);
                            heap.insert({ id: neighbor, dist: newDistance });
                        }
                    }
                }

                // Reconstruct path
                if (distances.get(endIndex) === Infinity) return null;

                const path = [];
                let current = endIndex;
                while (current !== undefined) {
                    path.unshift(current);
                    current = previous.get(current);
                }

                return {
                    path: path,
                    distance: distances.get(endIndex) * this.G
                };
            }

            getStarDistance(starA, starB) {
                const a = this.st[starA];
                const b = this.st[starB];
                return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
            }



            updateCursorDisplay() {
                // Remove existing cursor display
                const existing = document.getElementById('cursorInfo');
                if (existing) existing.remove();

                if (!this.showCursorInfo || this.tm >= this.tms.length) return;

                const movesLeft = this.tms[this.tm].movesLeft;
                const teamColor = `#${this.tms[this.tm].c.toString(16).padStart(6, '0')}`;

                const cursorDiv = document.createElement('div');
                cursorDiv.id = 'cursorInfo';
                cursorDiv.style.cssText = `
                    position: fixed;
                    left: ${this.cursorPos.x - 20}px;
                    top: ${this.cursorPos.y - 25}px;
                    color: ${teamColor};
                    font-size: 16px;
                    font-weight: bold;
                    pointer-events: none;
                    z-index: 10000;
                `;
                cursorDiv.textContent = movesLeft.toString();
                document.body.appendChild(cursorDiv);
            }

            isConnectionBroken(connection, teamId) {
                // Check if any star in the path is no longer owned by the team
                return connection.path.some(starIndex => this.st[starIndex].tm !== teamId);
            }

            getHQConnectionScore(teamId) {
                const connections = this.hqConnections.get(teamId);
                if (!connections || connections.size === 0) return 0;

                // Sum up scores from all HQ connections
                let totalScore = 0;
                for (const [connectionId, connection] of connections) {
                    // Count the number of lines in the connection (path length - 1)
                    const lineCount = connection.path.length - 1;
                    totalScore += lineCount;
                }
                return totalScore;

                // Calculate total distance of the connection
                const totalDistance = connection.distance;

                // Return raw value (line count + distance) for display in scoreboard
                return Math.round(lineCount + totalDistance);
            }



            // Optimized version that reuses adjacency cache and only checks when needed
            checkSpecialOptimized() {
                // Only check black holes - use existing adjacency cache
                for (let i = 0; i < this.st.length; i++) {
                    const s = this.st[i];
                    if (s.ty === T.B) {
                        s.ful = [];

                        for (let j = 0; j < this.tms.length; j++) {
                            const connectedCount = this.countConnectedBlackholes(i, j);

                            if (connectedCount >= s.req) {
                                s.ful.push(j);

                                // Check if this creates a valid blackhole connection for activation
                                this.checkBlackholeActivation(i, j);
                            }
                        }
                    }
                }
            }

            countConnOptimized(star, team, adjacency) {
                let count = 0;
                const neighbors = adjacency[star];
                for (let i = 0; i < neighbors.length; i++) {
                    if (this.st[neighbors[i]].tm === team) {
                        count++;
                    }
                }
                return count;
            }

            // Optimized version using cached adjacency
            countConnCached(star, team) {
                let count = 0;
                const neighbors = this.adjacencyCache[star];
                for (let i = 0; i < neighbors.length; i++) {
                    if (this.st[neighbors[i]].tm === team) {
                        count++;
                    }
                }
                return count;
            }

            // Count connected blackholes for a team (including the blackhole itself if owned by team)
            countConnectedBlackholes(blackholeIndex, team) {
                let count = 0;
                const visited = new Set();
                const queue = [blackholeIndex];
                visited.add(blackholeIndex);

                while (queue.length > 0) {
                    const currentStar = queue.shift();
                    const star = this.st[currentStar];

                    // If this is a blackhole and connected to the team, count it
                    if (star.ty === T.B && this.isBlackholeConnectedToTeam(currentStar, team)) {
                        count++;
                    }

                    // Explore neighbors through valid paths
                    const neighbors = this.adjacencyCache[currentStar];
                    for (let i = 0; i < neighbors.length; i++) {
                        const neighborIndex = neighbors[i];

                        if (!visited.has(neighborIndex) && this.isValidBlackholePath(currentStar, neighborIndex, team)) {
                            visited.add(neighborIndex);
                            queue.push(neighborIndex);
                        }
                    }
                }

                return count;
            }

            // Check if a blackhole is connected to a team (has team members connected to it)
            isBlackholeConnectedToTeam(blackholeIndex, team) {
                const neighbors = this.adjacencyCache[blackholeIndex];
                for (let i = 0; i < neighbors.length; i++) {
                    const neighbor = this.st[neighbors[i]];
                    if (neighbor.tm === team) {
                        return true;
                    }
                }
                return false;
            }

            // Check if a path between two stars is valid for blackhole connections
            isValidBlackholePath(fromIndex, toIndex, team) {
                const fromStar = this.st[fromIndex];
                const toStar = this.st[toIndex];

                // Path cannot have HQ dots, wormholes, cluster dots, or other blackholes (except endpoints)
                if (toStar.hq || toStar.ty === T.W || toStar.ty === T.C) {
                    return false;
                }

                // If destination is a blackhole, it's valid
                if (toStar.ty === T.B) {
                    return true;
                }

                // If destination is a normal star owned by the team, it's valid
                if (toStar.ty === T.N && toStar.tm === team) {
                    return true;
                }

                return false;
            }

            // Check blackhole activation
            checkBlackholeActivation(blackholeIndex, team) {
                const allBlackholes = [];
                for (let i = 0; i < this.st.length; i++) {
                    if (this.st[i].ty === T.B && this.st[i].ful && this.st[i].ful.includes(team)) {
                        allBlackholes.push(i);
                    }
                }

                for (let i = 0; i < allBlackholes.length; i++) {
                    for (let j = i + 1; j < allBlackholes.length; j++) {
                        const bh1 = allBlackholes[i], bh2 = allBlackholes[j];
                        const path = this.findFullPathBetweenBlackholes(bh1, bh2, team);
                        if (path.length > 0) {
                            const totalConnected = allBlackholes.length;
                            if (totalConnected >= this.st[bh1].req && totalConnected >= this.st[bh2].req) {
                                this.activateBlackholeNetwork(allBlackholes, team);
                                return;
                            }
                        }
                    }
                }
            }



            // Activate blackhole network
            activateBlackholeNetwork(blackholes, team) {
                const pathsToDestroy = [];
                for (let i = 0; i < blackholes.length; i++) {
                    for (let j = i + 1; j < blackholes.length; j++) {
                        const path = this.findFullPathBetweenBlackholes(blackholes[i], blackholes[j], team);
                        if (path.length > 0) pathsToDestroy.push(...path);
                    }
                }
                this.createBlackholeParticleEffect(pathsToDestroy, blackholes, team);
                this.destroyBlackholePaths(pathsToDestroy, team);
                this.updatePathsAfterDestruction();
            }

            // Find the complete path between two blackholes
            findFullPathBetweenBlackholes(blackhole1, blackhole2, team) {
                const visited = new Set();
                const queue = [{ index: blackhole1, path: [blackhole1] }];
                visited.add(blackhole1);

                while (queue.length > 0) {
                    const { index: currentIndex, path } = queue.shift();

                    if (currentIndex === blackhole2) {
                        return path;
                    }

                    const neighbors = this.adjacencyCache[currentIndex];
                    for (let i = 0; i < neighbors.length; i++) {
                        const neighborIndex = neighbors[i];

                        if (!visited.has(neighborIndex) &&
                            this.isValidBlackholePath(currentIndex, neighborIndex, team)) {
                            visited.add(neighborIndex);
                            queue.push({ index: neighborIndex, path: [...path, neighborIndex] });
                        }
                    }
                }

                return [];
            }

            // Create blackhole destruction particles
            createBlackholeParticleEffect(pathNodes, blackholes, team) {
                const teamColor = this.tms[team].c;
                for (const nodeIndex of pathNodes) {
                    const node = this.st[nodeIndex];
                    if (node.ty === T.B) continue;

                    let nearestBlackhole = blackholes[0], minDistance = Infinity;
                    for (const bhIndex of blackholes) {
                        const bh = this.st[bhIndex];
                        const distance = Math.sqrt((node.x - bh.x) ** 2 + (node.y - bh.y) ** 2);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestBlackhole = bhIndex;
                        }
                    }

                    this.fx.push({
                        type: 'blackhole_destruction',
                        x: node.x * this.G, y: node.y * this.G,
                        targetX: this.st[nearestBlackhole].x * this.G,
                        targetY: this.st[nearestBlackhole].y * this.G,
                        life: 1.0, maxLife: 1.0, color: teamColor
                    });
                }
                this.needsFxRedraw = true;
            }

            // Destroy the paths between blackholes
            destroyBlackholePaths(pathNodes, team) {
                // Mark stars as destroyed
                for (const nodeIndex of pathNodes) {
                    const node = this.st[nodeIndex];
                    if (node.ty !== T.B && !node.destroyed) { // Don't destroy blackholes themselves or already destroyed stars
                        node.destroyed = true;
                        node.destroyedBy = team;
                        node.destroyedScore = this.calculateDestroyedScore();
                        node.tm = null; // Remove original ownership
                        this.needsDestroyedRedraw = true;
                    }
                }

                // Mark connected lines as destroyed
                for (let i = 0; i < this.ln.length; i++) {
                    const line = this.ln[i];
                    const starA = this.st[line.f];
                    const starB = this.st[line.t];

                    // If either endpoint is destroyed and line isn't already destroyed, destroy the line
                    if ((starA.destroyed || starB.destroyed) && !line.destroyed) {
                        line.destroyed = true;
                        line.destroyedBy = team;
                        line.destroyedScore = this.calculateDestroyedScore();
                        this.needsDestroyedRedraw = true;
                    }
                }

                // Mark for redraw
                this.needsStarRedraw = true;
                this.needsStaticLineRedraw = true;
                this.needsAnimatedLineRedraw = true;
            }

            // Update all paths after blackhole destruction
            updatePathsAfterDestruction() {
                this.hqConnections.clear();
                this.usedHQLines.clear();
                this.clusterCache.clear();
                this.changedTeams.clear();
                for (let i = 0; i < this.tms.length; i++) this.changedTeams.add(i);
                this.deferredNetworkAnalysis = true;
            }



            // Optimized version using cached adjacency
            checkWormholeOptimized() {
                const w = {};

                for (let i = 0; i < this.st.length; i++) {
                    const s = this.st[i];
                    if (s.ty === T.W && s.tm !== null) {
                        const connectedCount = this.countConnCached(i, s.tm);

                        if (connectedCount >= s.req) {
                            w[s.tm] = (w[s.tm] || 0) + 1;

                            // Check for path overlaps (wormhole paths cannot overlap)
                            if (this.checkWormholePathOverlap(i, s.tm)) {
                                w[s.tm]--; // Remove this wormhole from count due to overlap
                            }
                        }
                    }
                }

                // Find the first team that has connected 2+ wormholes
                for (const [teamId, count] of Object.entries(w)) {
                    if (count >= 2) {
                        return parseInt(teamId); // Return the winning team ID
                    }
                }

                return false; // No team has won yet
            }

            // Check if wormhole paths overlap (wormhole paths cannot overlap)
            checkWormholePathOverlap(wormholeIndex, team) {
                // For now, return false (no overlap) - can be enhanced later
                // This is where you'd implement path overlap detection
                return false;
            }

            updateAIBots(currentTime) {
                if (!this.p && !this.go && this.aiBots.length > 0) {
                    // Only update AI during active gameplay, not planning or game over
                    if (currentTime - this.lastAIUpdate > this.aiUpdateInterval) {
                        let anyMovesMade = false;
                        this.aiBots.forEach(bot => {
                            if (bot.makeMove(this)) {
                                // AI move executed - visual updates already handled in executeMove
                                this.deferredScoreUpdate = true;
                                anyMovesMade = true;
                            }
                        });
                        
                        // Force immediate UI update if any AI made moves
                        if (anyMovesMade) {
                            this.calcScores();
                            this.updateUI();
                        }
                        
                        this.lastAIUpdate = currentTime;
                    }
                }
            }

            updateUI() {
                document.getElementById('round').textContent = this.go ? "Game Over" : `Round #${this.r}`;
                const timerEl = document.getElementById('timer');
                if (this.go) {
                    let winningTeamColor;

                    // Use wormhole winner's color if available, otherwise highest score
                    if (this.wormholeWinner !== null) {
                        winningTeamColor = `#${this.tms[this.wormholeWinner].c.toString(16).padStart(6, '0')}`;
                    } else {
                        const sortedData = [...this.teamScoreData].sort((a, b) => b.finalScore - a.finalScore);
                        winningTeamColor = `#${sortedData[0].team.c.toString(16).padStart(6, '0')}`;
                    }

                    timerEl.style.display = 'block';
                    timerEl.style.width = '100%';
                    timerEl.style.background = winningTeamColor;
                } else {
                    if (!this.p) {
                        timerEl.style.display = 'block';
                        timerEl.style.background = 'white';
                    }
                }
                // Only update scoreboard if scores actually changed
                if (this.needsFullUIUpdate || this.hasScoreChanges()) {
                    this.updateScoreDisplay();
                    this.needsFullUIUpdate = false;
                }
                this.updateHeader();
            }

            // Check if scores have actually changed since last update
            hasScoreChanges() {
                if (!this.lastScoreSnapshot) return true;

                // Quick check - if team count changed, definitely need update
                if (this.lastScoreSnapshot.length !== this.teamScoreData.length) return true;

                // Check if any scores changed
                for (let i = 0; i < this.teamScoreData.length; i++) {
                    const current = this.teamScoreData[i];
                    const last = this.lastScoreSnapshot[i];
                    if (!last ||
                        current.finalScore !== last.finalScore ||
                        current.steals !== last.steals ||
                        current.count !== last.count ||
                        current.distance !== last.distance ||
                        current.hqDistance !== last.hqDistance) {
                        return true;
                    }
                }
                return false;
            }

            // Fast UI update - only essential visual changes, no heavy calculations
            updateUIFast() {
                // Only update the team color display and moves counter - skip expensive scoreboard rebuild
                this.updateHeader();

                // Mark that we need a full UI update later
                this.needsFullUIUpdate = true;
            }

            updateHeader() {
                const header = document.getElementById('gameHeader');
                const titleLine = document.getElementById('titleLine');
                const teamColorSpan = document.getElementById('teamColor');

                if (this.ml) {
                    header.style.display = 'block';
                    let titleText = '';
                    if (this.cm && this.cm.title) {
                        titleText = `${this.cm.title}`;
                        if (this.cm.author) {
                            titleText += ` by ${this.cm.author}`;
                        }
                    }
                    titleLine.textContent = titleText;

                    // Use the current team's name in lowercase
                    if (this.tm < this.tms.length) {
                        teamColorSpan.textContent = this.tms[this.tm].name;
                        teamColorSpan.style.color = `#${this.tms[this.tm].c.toString(16).padStart(6, '0')}`;
                    }
                } else {
                    header.style.display = 'none';
                }
            }

            updateScoreDisplay() {
                const scoresEl = document.getElementById('scores');
                const sortedData = [...this.teamScoreData].sort((a, b) => b.finalScore - a.finalScore);

                // Only calculate widths for columns that will be shown (multiplier > 0)
                const showCount = MULTIPLIERS.count > 0;
                const showDistance = MULTIPLIERS.distance > 0;
                const showHQ = MULTIPLIERS.hq > 0;
                const showDestruction = MULTIPLIERS.destruction > 0;

                const maxCountWidth = showCount ? Math.max(...sortedData.map(d => d.count.toString().length)) * 8 + 16 : 0;
                const maxDistWidth = showDistance ? Math.max(...sortedData.map(d => d.distance.toString().length)) * 8 + 16 : 0;
                const maxHQWidth = showHQ ? Math.max(...sortedData.map(d => d.hqDistance.toString().length)) * 8 + 16 : 0;
                const maxDestructionWidth = showDestruction ? Math.max(...sortedData.map(d => d.destruction.toString().length)) * 8 + 16 : 0;

                let html = '';
                sortedData.forEach((data, index) => {
                    const color = `#${data.team.c.toString(16).padStart(6, '0')}`;
                    const isCurrentTeam = data.teamIdx === this.tm;
                    const isWormholeWinner = this.wormholeWinner !== null && data.teamIdx === this.wormholeWinner;

                    // Check if this team has an AI bot
                    const aiBot = this.aiBots.find(bot => bot.teamIndex === data.teamIdx);
                    const aiIndicator = aiBot ? this.createAIIndicator(aiBot, color) : '';

                    // Display "Won" for wormhole winner, otherwise show score
                    const displayScore = isWormholeWinner ? "Won" : data.finalScore;
                    const scoreWidth = displayScore.toString().length * 9 + 36 + (isCurrentTeam ? 8 : 0);
                    const teamBorder = isCurrentTeam ? `outline: 2px solid ${color}; outline-offset: -2px; padding: 0 4px;` : '';

                    html += `<div class="score-row" data-team-index="${data.teamIdx}" style="${teamBorder}" title="Click to select ${data.team.displayName} team${aiBot ? ' (AI: ' + aiBot.config.name + ')' : ''}">
                            <div class="main-score-section">
                                <div class="score-highlight" style="background:${color};width:${scoreWidth}px;"></div>
                                <div class="score-content">
                                    ${aiIndicator}
                                    <div class="steal-circle">${data.steals}</div>
                                    <span class="score-number">${displayScore}</span>
                                </div>
                            </div>
                            <div class="detail-section">
                                ${showCount ? `<span class="detail-col" style="color:${color};width:${maxCountWidth}px;">${data.count}</span>` : ''}
                                ${showDistance ? `<span class="detail-col" style="color:${color};width:${maxDistWidth}px;">${data.distance}</span>` : ''}
                                ${showHQ ? `<span class="detail-col" style="color:${color};width:${maxHQWidth}px;">${data.hqDistance}</span>` : ''}
                                ${showDestruction ? `<span class="detail-col" style="color:${color};width:${maxDestructionWidth}px;">${data.destruction}</span>` : ''}
                            </div>
                        </div>`;
                });

                html += `<div class="score-row multiplier-row">
                        <div class="main-score-section" style="visibility:hidden;">
                            <div class="score-content">
                                <div class="steal-circle"></div>
                                <span class="score-number"></span>
                            </div>
                        </div>
                        <div class="multipliers">
                            ${showCount ? `<span class="multiplier-col" style="color:#ccc;width:${maxCountWidth}px;">${MULTIPLIERS.count}x</span>` : ''}
                            ${showDistance ? `<span class="multiplier-col" style="color:#ccc;width:${maxDistWidth}px;">${MULTIPLIERS.distance}x</span>` : ''}
                            ${showHQ ? `<span class="multiplier-col" style="color:#ccc;width:${maxHQWidth}px;">${MULTIPLIERS.hq}x</span>` : ''}
                            ${showDestruction ? `<span class="multiplier-col" style="color:#ccc;width:${maxDestructionWidth}px;">${MULTIPLIERS.destruction}x</span>` : ''}
                        </div>
                    </div>`;

                scoresEl.innerHTML = html;
                this.setupScoreboardEvents();

                // Save snapshot of current scores for change detection
                this.lastScoreSnapshot = this.teamScoreData.map(data => ({
                    finalScore: data.finalScore,
                    steals: data.steals,
                    count: data.count,
                    distance: data.distance,
                    hqDistance: data.hqDistance
                }));
            }

            createAIIndicator(aiBot, teamColor) {
                // Remove AI indicator icons from scoreboard as requested
                return '';
            }

            renderBackground() {
                this.bgGfx.clear().lineStyle(2, 0x808080);
                const x = this.mapBounds.minX * this.G, y = this.mapBounds.minY * this.G;
                const w = (this.mapBounds.maxX - this.mapBounds.minX) * this.G, h = (this.mapBounds.maxY - this.mapBounds.minY) * this.G;
                this.bgGfx.drawRect(x, y, w, h);
            }

            // Render destroyed lines and dots on the bottom layer
            renderDestroyed() {
                this.destroyedGfx.clear();

                // Render destroyed lines
                this.lineData.forEach((l, lineIndex) => {
                    const line = this.ln[lineIndex];
                    if (line && line.destroyed) {
                        this.destroyedGfx.lineStyle(4, 0x000000).moveTo(l.x1, l.y1).lineTo(l.x2, l.y2);
                    }
                });

                // Render destroyed stars (dots)
                this.st.forEach((s, i) => {
                    if (s.destroyed) {
                        const x = s.x * this.G, y = s.y * this.G;
                        let sz = this.G / 2;
                        if (s.ty === T.C) sz *= 1.5;
                        else if (s.ty === T.B) sz *= 1.5;
                        this.destroyedGfx.lineStyle(0).beginFill(0x000000).drawCircle(x, y, sz).endFill();
                    }
                });
            }

            // Render static lines (no animations) - called rarely
            renderStaticLines() {
                this.staticLineGfx.clear();
                this.lto.forEach(t => t.visible = false);
                this.lti = 0;

                this.lineData.forEach((l, lineIndex) => {
                    const line = this.ln[lineIndex];
                    const a = this.st[l.f], b = this.st[l.t];

                    // Skip destroyed lines - they're rendered in the destroyed layer
                    if (line && line.destroyed) {
                        return;
                    }

                    // Priority 2: Render line text for non-destroyed lines
                    const txt = this.getLineText(l.dist.toString(), l.cx + Math.cos(l.pang) * 5, l.cy + Math.sin(l.pang) * 5, { fontSize: 10, fill: 0xFFFFFF, fontFamily: 'Arial' });
                    txt.rotation = Math.abs(l.ang) > Math.PI / 2 ? l.ang + Math.PI : l.ang;

                    // Priority 3: Check if this line is animated (HQ or protected)
                    let isAnimated = (this.connected(a, b) && (a.pr || b.pr));
                    if (!isAnimated) {
                        for (const [teamId, connections] of this.hqConnections) {
                            for (const [connectionId, connection] of connections) {
                                if (this.isLineInHQPath(l.f, l.t, connection.path)) {
                                    isAnimated = true;
                                    break;
                                }
                            }
                            if (isAnimated) break;
                        }
                    }

                    // Priority 4: Render non-animated lines
                    if (!isAnimated) {
                        let color = 0xFFFFFF, th = 2;
                        if (this.connected(a, b)) {
                            const team = a.ty === T.B ? b.tm : a.tm;
                            if (team !== null) {
                                color = this.tms[team].c;
                                th = 4;
                            }
                        }
                        this.staticLineGfx.lineStyle(th, color).moveTo(l.x1, l.y1).lineTo(l.x2, l.y2);
                    }
                });
            }

            // Render animated lines only - called every animation frame
            renderAnimatedLines() {
                this.animatedLineGfx.clear();

                this.lineData.forEach((l, lineIndex) => {
                    const line = this.ln[lineIndex];
                    const a = this.st[l.f], b = this.st[l.t];
                    let color = 0xFFFFFF, th = 2;
                    let isAnimated = false;

                    // Skip destroyed lines (they're rendered in the destroyed layer)
                    if (line && line.destroyed) return;

                    // Check if this line is part of an HQ connection
                    let isHQConnection = false;
                    for (const [teamId, connections] of this.hqConnections) {
                        for (const [connectionId, connection] of connections) {
                            if (this.isLineInHQPath(l.f, l.t, connection.path)) {
                                isHQConnection = true;
                                isAnimated = true;
                                break;
                            }
                        }
                        if (isHQConnection) break;
                    }

                    // Check if protected (logical: if line is connected and either star is protected)
                    const isProtected = this.connected(a, b) && (a.pr || b.pr);
                    if (isProtected) {
                        isAnimated = true;
                    }

                    // Only render animated lines
                    if (isAnimated && this.connected(a, b)) {
                        const team = a.ty === T.B ? b.tm : a.tm;
                        if (team !== null) {
                            color = this.tms[team].c;
                            th = 4;

                            // Apply protected line effect
                            if (isProtected) {
                                th += (Math.sin(this.pu) + 1) * 1.5;
                            }

                            // Apply HQ connection effect
                            if (isHQConnection) {
                                const hqPulse = (Math.sin(this.hqConnectionPulse) + 1) * 0.5;
                                const teamR = (color >> 16) & 0xFF;
                                const teamG = (color >> 8) & 0xFF;
                                const teamB = color & 0xFF;
                                const r = Math.round(teamR + (255 - teamR) * hqPulse);
                                const g = Math.round(teamG + (255 - teamG) * hqPulse);
                                const b = Math.round(teamB + (255 - teamB) * hqPulse);
                                color = (r << 16) | (g << 8) | b;
                            }
                        }
                        this.animatedLineGfx.lineStyle(th, color).moveTo(l.x1, l.y1).lineTo(l.x2, l.y2);
                    }
                });
            }

            isLineInHQPath(starA, starB, path) {
                // Check if the line between starA and starB is part of the HQ connection path
                for (let i = 0; i < path.length - 1; i++) {
                    if ((path[i] === starA && path[i + 1] === starB) ||
                        (path[i] === starB && path[i + 1] === starA)) {
                        return true;
                    }
                }
                return false;
            }



            drawHQOutline(x, y, s) {
                const th = 6; let sz = this.G / 2; this.starGfx.lineStyle(th, 0xFFFFFF).beginFill(0, 0);
                if (s.ty === T.W) { this.starGfx.moveTo(x, y + sz * 2.5).lineTo(x - sz * 2.1625, y - sz * 1.25).lineTo(x + sz * 2.1625, y - sz * 1.25).closePath(); }
                else if (s.ty === T.B) { sz *= 1.8; this.starGfx.drawCircle(x, y, sz); }
                else if (s.ty === T.C) { sz *= 1.5; this.starGfx.drawRect(x - sz, y - sz, sz * 2, sz * 2); }
                else this.starGfx.drawCircle(x, y, sz); this.starGfx.endFill();
            }

            // Optimized star rendering with dirty regions
            renderStars() {
                if (!this.needsStarRedraw && this.dirtyRegions.size === 0 && this.dirtyStars.size === 0) return;

                if (this.needsStarRedraw) {
                    // Full redraw
                    this.starGfx.clear();
                    this.to.forEach(t => t.visible = false);
                    this.ti = 0;
                    for (let i = 0; i < this.st.length; i++) {
                        this.drawStar(this.st[i], i);
                    }
                } else {
                    // Partial redraw - prioritize individual stars (much faster)
                    if (this.dirtyStars.size > 0) {
                        this.dirtyStars.forEach(starIndex => {
                            if (starIndex < this.st.length) {
                                this.drawStar(this.st[starIndex], starIndex);
                            }
                        });
                    }

                    // Handle dirty regions if any (fallback)
                    this.dirtyRegions.forEach(region => {
                        const [rx, ry] = region.split(',').map(Number);
                        const minX = rx * this.regionSize;
                        const maxX = (rx + 1) * this.regionSize;
                        const minY = ry * this.regionSize;
                        const maxY = (ry + 1) * this.regionSize;

                        for (let i = 0; i < this.st.length; i++) {
                            const s = this.st[i];
                            const sx = s.x * this.G, sy = s.y * this.G;
                            if (sx >= minX && sx < maxX && sy >= minY && sy < maxY) {
                                this.drawStar(s, i);
                            }
                        }
                    });
                }

                this.dirtyRegions.clear();
                this.dirtyStars.clear();
            }

            drawStar(s, i) {
                // Skip destroyed stars - they're rendered in the destroyed layer
                if (s.destroyed) return;

                const x = s.x * this.G, y = s.y * this.G;
                let sz = this.G / 2;
                const color = s.tm !== null ? this.tms[s.tm].c : 0xFFFFFF;

                if (s.hq) this.drawHQOutline(x, y, s);
                this.starGfx.lineStyle(0);

                if (s.ty === T.W) {
                    this.starGfx.beginFill(color).moveTo(x, y + sz * 2.5).lineTo(x - sz * 2.1625, y - sz * 1.25).lineTo(x + sz * 2.1625, y - sz * 1.25).closePath().endFill();
                } else if (s.ty === T.B) {
                    sz *= 1.5;
                    if (s.ful && s.ful.length) {
                        const sega = (Math.PI * 2) / s.ful.length, or = sz * 1.2, ir = sz;
                        s.ful.forEach((t, j) => {
                            this.starGfx.beginFill(this.tms[t].c);
                            const sa = j * sega + this.bhr, ea = (j + 1) * sega + this.bhr, segs = Math.max(1, Math.ceil(sega * 16)), as = (ea - sa) / segs;
                            this.starGfx.moveTo(x + Math.cos(sa) * ir, y + Math.sin(sa) * ir).lineTo(x + Math.cos(sa) * or, y + Math.sin(sa) * or);
                            for (let k = 1; k <= segs; k++) { const a = sa + as * k; this.starGfx.lineTo(x + Math.cos(a) * or, y + Math.sin(a) * or); }
                            this.starGfx.lineTo(x + Math.cos(ea) * ir, y + Math.sin(ea) * ir);
                            for (let k = segs - 1; k >= 0; k--) { const a = sa + as * k; this.starGfx.lineTo(x + Math.cos(a) * ir, y + Math.sin(a) * ir); }
                            this.starGfx.endFill();
                        });
                    } else {
                        this.starGfx.beginFill(0xFFFFFF).drawCircle(x, y, sz * 1.2).endFill();
                    }
                    this.starGfx.beginFill(0x000000).drawCircle(x, y, sz).endFill();
                } else if (s.ty === T.C) {
                    sz *= 1.5;
                    this.starGfx.beginFill(color).drawRect(x - sz, y - sz, sz * 2, sz * 2).endFill();
                } else {
                    this.starGfx.beginFill(color).drawCircle(x, y, sz).endFill();
                }

                if (s.pr && s.ty !== T.C) {
                    // Draw yellow X for protected stars
                    this.starGfx.lineStyle(3, 0xFFFF00);
                    const xSize = sz * 0.8;
                    this.starGfx.moveTo(x - xSize, y - xSize).lineTo(x + xSize, y + xSize);
                    this.starGfx.moveTo(x + xSize, y - xSize).lineTo(x - xSize, y + xSize);
                }

                // Draw text for special stars
                if (s.ty >= T.B) {
                    let rt = this.p ? (s.min_value !== undefined && s.max_value !== undefined ?
                        (s.min_value === s.max_value ? s.min_value.toString() : `${s.min_value}-${s.max_value}`) :
                        (s.ty === T.B ? '2-4' : '2-3')) : (s.req ? s.req.toString() : null);
                    if (rt) {
                        const tc = s.ty === T.B ? 0xFFFFFF : 0x000000;
                        this.getText(rt, x, y, { fontSize: this.G / 1.4, fill: tc, fontFamily: 'Arial', fontWeight: 'bold' });
                    }
                }
            }

            renderFx() {
                this.fxGfx.clear();
                this.fx.forEach(e => {
                    if (e.ty === 'steal') {
                        const p = e.t / e.mt;
                        const r = p * 150, a = 1 - p; this.fxGfx.lineStyle(9, 0xFFFFFF, a).drawCircle(e.x, e.y, r);
                        if (p < 0.5) { const ir = p * 60, ia = (1 - p * 2) * 0.5; this.fxGfx.lineStyle(6, 0xFFFF00, ia).drawCircle(e.x, e.y, ir); }
                    } else if (e.ty === 'pointer') {
                        const p = e.t / e.mt;
                        const pointerColor = this.tm < this.tms.length ? this.tms[this.tm].c : 0x00FFFF;
                        const r = (1 - p) * 120, a = 1 - p; this.fxGfx.lineStyle(9, pointerColor, a).drawCircle(e.x, e.y, r);
                        if (p > 0.3) { const dr = (p - 0.3) * 24, da = 1 - p; this.fxGfx.lineStyle(0).beginFill(pointerColor, da).drawCircle(e.x, e.y, dr).endFill(); }
                    } else if (e.type === 'blackhole_destruction') {
                        // Render blackhole destruction particle effect
                        const progress = 1 - e.life;
                        const currentX = e.x + (e.targetX - e.x) * progress;
                        const currentY = e.y + (e.targetY - e.y) * progress;

                        // Particle trail effect
                        const alpha = e.life;
                        const size = 3 + Math.sin(progress * Math.PI * 4) * 2;

                        // Use team color if available, otherwise default to red
                        const particleColor = e.color || 0xFF4444;
                        this.fxGfx.lineStyle(0).beginFill(particleColor, alpha).drawCircle(currentX, currentY, size).endFill();

                        // Update particle
                        e.life -= 0.02; // Adjust speed as needed
                    }
                });
            }


        }

        let currentGame = null;

        function getSettings() {
            return {
                steals: +document.getElementById('steals').value, headquarters: +document.getElementById('headquarters').value,
                roundLength: +document.getElementById('roundLength').value, rounds: +document.getElementById('rounds').value,
                countdownLength: +document.getElementById('countdownLength').value, customMap: parseMapJSON(),
                multipliers: {
                    count: +document.getElementById('countMultiplier').value,
                    distance: +document.getElementById('distanceMultiplier').value,
                    hq: +document.getElementById('hqMultiplier').value,
                    destruction: +document.getElementById('destructionMultiplier').value
                },
                aiBots: getAIBots()
            };
        }

        function parseMapJSON() {
            const jsonText = document.getElementById('mapJson').value.trim(), errorDiv = document.getElementById('mapError');
            errorDiv.classList.add('hidden'); if (!jsonText) return null;
            try {
                const mapData = JSON.parse(jsonText);
                if (!mapData.stars || !Array.isArray(mapData.stars)) throw new Error('Map must contain a "stars" array');
                if (!mapData.lines || !Array.isArray(mapData.lines)) throw new Error('Map must contain a "lines" array');
                for (let i = 0; i < mapData.stars.length; i++) {
                    const star = mapData.stars[i];
                    if (!Array.isArray(star) || star.length < 3) throw new Error(`Star ${i} must be an array with at least [x, y, type]`);
                    if (typeof star[0] !== 'number' || typeof star[1] !== 'number' || typeof star[2] !== 'number')
                        throw new Error(`Star ${i} coordinates and type must be numbers`);
                    if (star[2] < 1 || star[2] > 4) throw new Error(`Star ${i} type must be 1-4 (1=NORMAL, 2=CLUSTER, 3=WORMHOLE, 4=BLACK_HOLE)`);
                }
                for (let i = 0; i < mapData.lines.length; i++) {
                    const line = mapData.lines[i]; let from, to;
                    if (Array.isArray(line)) {
                        if (line.length !== 2) throw new Error(`Line ${i} array must have exactly 2 elements [from, to]`);
                        [from, to] = line;
                    } else if (typeof line === 'object') { ({ from, to } = line); }
                    else throw new Error(`Line ${i} must be an array [from, to] or object {from, to}`);
                    if (typeof from !== 'number' || typeof to !== 'number') throw new Error(`Line ${i} from and to must be numbers`);
                    if (from < 0 || from >= mapData.stars.length || to < 0 || to >= mapData.stars.length)
                        throw new Error(`Line ${i} references invalid star indices`);
                }
                return mapData;
            } catch (e) { errorDiv.textContent = `JSON Error: ${e.message}`; errorDiv.classList.remove('hidden'); return null; }
        }

        function startNewGame() {
            const settings = getSettings(); if (document.getElementById('mapJson').value.trim() && !settings.customMap) return;

            // Clean up cursor display
            const existing = document.getElementById('cursorInfo');
            if (existing) existing.remove();

            if (currentGame && currentGame.app) currentGame.app.destroy(true);
            document.getElementById('gameContainer').innerHTML = ''; currentGame = new Game(settings);
            document.getElementById('settingsPanel').classList.add('hidden');
        }

        function toggleSettings() {
            const panel = document.getElementById('settingsPanel'), button = event.target;
            if (panel.classList.contains('hidden')) { panel.classList.remove('hidden'); button.textContent = 'Hide Settings'; }
            else { panel.classList.add('hidden'); button.textContent = 'Show Settings'; }
        }

        // AI Bot Management Functions
        let aiBotCounter = 0;

        function addAIBot() {
            const botsList = document.getElementById('aiBotsList');

            // Remove empty message if it exists
            const emptyMessage = botsList.querySelector('p');
            if (emptyMessage) {
                emptyMessage.remove();
            }

            const botId = `aiBot_${aiBotCounter++}`;
            const botDiv = document.createElement('div');
            botDiv.className = 'ai-bot-item';
            botDiv.id = botId;

            botDiv.innerHTML = `
                <select class="ai-bot-select" onchange="updateAIBotDisplay('${botId}')">
                    ${Object.keys(AI_BOT_TYPES).map(key =>
                `<option value="${key}">${AI_BOT_TYPES[key].name} - ${AI_BOT_TYPES[key].description}</option>`
            ).join('')}
                </select>
                <select class="ai-team-select">
                    ${TEAM_CONFIGS.map((team, index) =>
                `<option value="${index}" style="color: #${team.color.toString(16).padStart(6, '0')}">${team.displayName}</option>`
            ).join('')}
                </select>
                <select class="ai-aggression-select">
                    <option value="0.1">Very Low (10%)</option>
                    <option value="0.3">Low (30%)</option>
                    <option value="0.5" selected>Medium (50%)</option>
                    <option value="0.7">High (70%)</option>
                    <option value="0.9">Very High (90%)</option>
                </select>
                <div class="ai-bot-cube" style="background: #00FFFF; opacity: 0.8;"></div>
                <button class="remove-bot-btn" onclick="removeAIBot('${botId}')">Remove</button>
            `;

            botsList.appendChild(botDiv);
            updateAIBotDisplay(botId);
        }

        function removeAIBot(botId) {
            const botDiv = document.getElementById(botId);
            if (botDiv) {
                botDiv.remove();

                // Add empty message if no bots left
                const botsList = document.getElementById('aiBotsList');
                if (botsList.children.length === 0) {
                    botsList.innerHTML = '<p style="color: #ccc; font-size: 12px; margin: 5px 0;">No AI bots added. Click "Add AI Bot" to add computer players.</p>';
                }
            }
        }

        function updateAIBotDisplay(botId) {
            const botDiv = document.getElementById(botId);
            if (!botDiv) return;

            const botSelect = botDiv.querySelector('.ai-bot-select');
            const teamSelect = botDiv.querySelector('.ai-team-select');
            const aggressionSelect = botDiv.querySelector('.ai-aggression-select');
            const cube = botDiv.querySelector('.ai-bot-cube');

            const botType = botSelect.value;
            const teamIndex = parseInt(teamSelect.value);
            const aggression = parseFloat(aggressionSelect.value);

            // Update cube appearance
            const teamColor = `#${TEAM_CONFIGS[teamIndex].color.toString(16).padStart(6, '0')}`;
            const opacity = 0.3 + (aggression * 0.7);

            cube.style.background = teamColor;
            cube.style.opacity = opacity;
            cube.title = `${AI_BOT_TYPES[botType].name} on ${TEAM_CONFIGS[teamIndex].displayName} team (${Math.round(aggression * 100)}% aggression)`;
        }

        function getAIBots() {
            const botsList = document.getElementById('aiBotsList');
            const botDivs = botsList.querySelectorAll('.ai-bot-item');
            const aiBots = [];

            botDivs.forEach(botDiv => {
                const botSelect = botDiv.querySelector('.ai-bot-select');
                const teamSelect = botDiv.querySelector('.ai-team-select');
                const aggressionSelect = botDiv.querySelector('.ai-aggression-select');

                const botType = botSelect.value;
                const teamIndex = parseInt(teamSelect.value);
                const aggression = parseFloat(aggressionSelect.value);

                aiBots.push(new AIBot(botType, teamIndex, aggression));
            });

            return aiBots;
        }

        // Initialize AI bot display updates
        document.addEventListener('change', function (e) {
            if (e.target.classList.contains('ai-team-select') || e.target.classList.contains('ai-aggression-select')) {
                const botDiv = e.target.closest('.ai-bot-item');
                if (botDiv) {
                    updateAIBotDisplay(botDiv.id);
                }
            }
        });

        const sampleMap = {
            title: "Sample Map", author: "Game Creator", dimensions: [32, 20],
            stars: [[5, 5, 1], [10, 5, 2], [15, 5, 1], [5, 10, 4, 3], [10, 10, 1], [15, 10, 3, 2], [5, 15, 1], [10, 15, 2], [15, 15, 1]],
            lines: [[0, 1], [1, 2], [3, 4], [4, 5], [6, 7], [7, 8], [0, 3], [1, 4], [2, 5], [3, 6], [4, 7], [5, 8]]
        };

        window.addEventListener('load', () => {
            document.getElementById('mapJson').placeholder = JSON.stringify(sampleMap, null, 2);

            // Initialize AI bot list as empty
            const aiBotsList = document.getElementById('aiBotsList');
            if (aiBotsList) {
                aiBotsList.innerHTML = '<p style="color: #ccc; font-size: 12px; margin: 5px 0;">No AI bots added. Click "Add AI Bot" to add computer players.</p>';
            }

            currentGame = new Game();
            window.addEventListener('resize', () => {
                if (currentGame && currentGame.app) { currentGame.app.renderer.resize(innerWidth, innerHeight); currentGame.setupCam(); }
            });
        });
    </script>
</body>

</html>